= What is finite element simulation? =

Houdini's finite element solver allows you to simulate the motion of deformable solids. This includes human tissue such as fat and muscles, but also much stiffer materials such as wood and cork. The finite element solver treats each simulated shape as a solid continuum, as opposed to a collision of particles. This means that the internal mass and the internal forces are distributed over the entire shape, including the interiors of the tetrahedra. The finite-element simulation is physically based, based on internal stresses and strains that occur within the simulated body. This contrasts strongly with other solvers, such as particle-based mass-spring systems, where the mass is concentrated in the vertices and where internal forces are generated by springs between these vertices.

The solid continuum approach of the finite element solver has several advantages over particle-based solvers, including:
- The simulation behavior stays very consistent if the mesh resolution changes. This makes the presets predictable; a simulation with a low-res mesh (cheap) is a good prediction of a simulation with a higher-res mesh.
- The results of finite element simulation are realistic. This is the result of finite elements being based on the principles of solid mechanics.
- Usually, finite element systems tend to be more efficient at simulating stiff objects than position-based particle systems.

= Tetrahedral meshes = 

- For the simulation of a Solid Object, the finite element solver requires a fully three-dimensional solid representation. The solver needs to know the three-dimensional region in space that is occupied by a shape. Usually, a model consists of triangles and/or quads, which constitute a two-dimensional surface. Such surface representations are essentially two-dimensional; they may form the boundary of a region in space, but not the region itself. To simulate such a boundary representation as a Solid Object using finite elements, it is necessary to generate a solid representation. In Houdini tetrahedral meshes (tet meshes) are used to represent solids for finite element simulation.

- When given a surface representation of model that must be simulated, a solid representation of this object must be obtained. For this to be possible, the surface representation must be the boundary of a well defined solid object; there must not be any "holes". If there are holes, it becomes very difficult or impossible for automated tools to determine which region in space is the interior and which region in space is the exterior. Also, the surface representation should not have self intersections. It is recommended that you use either Solid Embed or Solid Conform to create a solid representation. Solid Embed is used by the Solid Object shelf tool.

- The Solid Embed SOP is usually the most effective option for finite element simulation. It may create a tetrahedral mesh that is slightly larger than the input surface representation. It is easy to tweak the resolution of the tet mesh that gets generated by tweaking the __Min Tet Size__ and __Max Tet Size__ parameters. If a tet mesh has too many tetrahedrons for efficient simulation, you may want to increase the __Min Tet Size__ parameter. Sometimes a tet mesh may have a few tetrahedra that are too large; in these cases where more detail is needed it may be advantageous to decrease the __Max Tet Size__. The Solid Embed SOP is used most effectively in combination with the __Embedded Geometry__ feature of the Solid Object. This option allow the original surface representation to be deformed along with the slightly larger tet mesh that is generated by Solid Embed. In this workflow, the tetrahedral mesh is nothing but a temporary cage that drives the deformation of the original surface mesh.

- The Solid Conform SOP can be used if a close match is needed with the original surface. This may be the case when finite elements is used with very detailed character animation. However, it is not recommended at all to use Solid Conform directly on a rendering geometry. Models that are used for rendering typically contain too many polygons to make a fast simulation possible. Also, the shapes of the polygons in a rendering geometry are a poor choice for finite element simulation, leading to poor simulation speeds. When a rendering model is all that's available, it is strongly recommended to first apply a Remesh SOP before the Solid Conform. In this case, the __Embedded Geometry__ on the Solid Object can be used to drive the animation of the original rendering model.

- The complexity and the quality of the used tetrahedral mesh has a large impact on the efficiency of a simulation. Generally, the more tets, the higher the simulation time. Generally, speaking 10 times more tets will translate to a simulation that is at least 10 times slower (possibly more than that).

- To achieve fast simulation, it is generally recommended to use as few tets as possible while still retaining enough mesh resolution to accurately represent the desired motion. The setup created by the 'Solid Object' shelf tool should be a good starting point. The Tet Size parameters on the Solid Embed SOP can be tweaked to influence the mesh resolution. For very high-quality character simulations, it may be desirable to exchange Solid Embed with a Remesh/Solid Conform SOP pair. The nature of finite element simulation ensures that simulations with lower-resolution tet meshes are good approximations of high-resolution tet meshes, as long as the overall shapes are similar.

- In addition to the number of tets, the shapes of the tets may have a significant effect on efficiency of the simulation as well. Ideally, all tetrahedrons closely resemble a regular tetrahedron. Tetrahedrons that are very small, very large, very flat or very thin have an adverse effect on a finite element simulation. The Solid Embed and Solid Conform tools are designed to generate good quality tetrahedrons.

= Shelf Tools =
Solid Object
Organic Tissue
Fractured Solid
Surface Collider
Volume Collider
Constrain Points to Target
Embed Highres Object

= What can you do with it? =

= Advantages compared with other solvers? =

In contrast to many other solvers, Houdini's finite element solver has the advantage of resolution independence.
This means that the way an object moves and deforms is to a large degree independent of the density of tetrahedrons.
In particular, the same settings on a Solid Object have similar results when applied to meshes of increasingly high resolution.
There is a point at which adding more tetrahedrons to a tet mesh does not significantly affect the simulated results.

= Do's and dont's =

Be careful what you do in SOP Solvers, when combined with finite element simulations.
In constrast with other solvers (e.g., the Grain Solver) you should not directly modify the position and velocity attributes ('P' and 'v', resp.) in a finite element simulation. When you want to influence a finite element simulation, it is recommended that you use the target constraints instead. 

Another thing to watch out for is the ratio between __Shape Stiffness__ and __Volume Stiffness__. When the __Volume Stiffness__ is set considerably higher than the __Shape Stiffness__ (say more than 2x), the results will usually not appear stable.

= FEM Solver Controls =

- Substeps
- Integrator Type BDF1, BDF2

= Directing Simulation using Animation

- Creating an interior animation from a surface animation

- Integration types:

= Solid Object Controls =

__Shape Stifness__
This determines how strongly a Solid Object locally retains its original shape.
The stronger this is, the stronger the internal forces that prevent the object from deforming. The more the shape stiffness is increased, the more rigid an object becomes.

__Volume Stiffness__
Volume stiffness determines how much a Solid Object locally retains volume. Pressing and object flat has a tendency to make it wider. This is called the Poisson effect. Increasing Volume Stiffness increases this effect. Some materials, such as cork, don't have this effect at all. The notions of shape preservation and volume preservation are often confused. Volume stiffness should never be used by itself, it always needs to be balanced with __Shape Stiffness__. Don't make __Volume Stiffness__ larger than say 2x the __Shape Stiffness__.

- Presets

= Embedding =

Meshes that are used for rendering tend to contain much more detail than is necessary for a good quality simulation. Creating a tet mesh that exactly fits such a rendering mesh can be problematic, due to holes and self intersections. Even when such a tet mesh can be obtained it may have a very high resolution and it may have many tetrahedrons that have poor quality for simulation purposes. Instead, it is recommended to use the embedding feature of the finite element solver to decouple the tet mesh that is used for simulation from the polygon mesh that may be used for rendering. The Solid Object shelf tool creates a setup that makes use the embedding feature. This setup can be used as an example for more customized embedded simulations.

The embedded geometry allows you to add extra detail to a simulation without having to directly simulate that extra detail. This option allows an embedded geometry to deform and fracture along with the simulated geometry. The deformation is smooth (better than barycentric) to ensure that there are no visible discontinuities when the embedded geometry is much more detailed than the simulated geometry. In addition, the embedded geometry is automatically fractured along with the simulated geometry, when the simulated geometry fractures.

When an embedded geometry is used with a tetrahedral mesh, it is important that the primitives of the embedded geometry lie in the interior of the tetrahedral mesh. If primitives or parts of primitives of the embedded mesh lie outside the tetrahedral mesh, then this may slow down the simulation or produce inferior results.
    
The point positions of the embedded geometry are computed for every simulation frame, based on the deformation of the simulated geometry. In addition to positions, velocities and point/vertex normals adapted to the deformation as well. The transformation of embedded point/vertex normals is useful for rendering purposes. The embedded velocities tend be useful when rendering the results of a simulation using motion blur.
    
Normals on the embedded geometry are deformed only when the normal attribute `N` is found on the Embedded Geometry. Both point and vertex normals are supported. The simplest way to use this feature is to put a [Normal SOP|Node:sop/normal] on the incoming Embedded Geometry.
    
The embedding workflow preserves the information that is generated by the directly simulated geometry; embedding geometry in itself gives identical results. Small, local deformations are not smoothed away.

For best results, make sure the geometry is entirely covered when embedding geometry inside a tetrahedral mesh.

The embedded geometry may consist of tetrahedrons and polygons or a mix of these two.  When internal fracture surfaces are desired, the embedded geometry must have tetrahedrons or polygons near the regions where the simulated geometry fractures.

The embedded geometry is not directly simulated. No internal forces are computed for it and no collisions are detected for it. The best results are obtained if, on object creation, the embedded geometry is completely contained inside the simulated geometry, when the simulated geometry points are in their initial rest positions (the rest positions at the object creation time).

When the `fracturepart` primitive attribute exists on the simulation geometry, an attribute with the same name may be added on the embedded geometry as well to control how the embedded geometry fractures.

Whenever an Embedded Geometry is used with a simulated tetrahedral mesh, the primitives of the embedded geometry are required to lie in the interior of the tetrahedral mesh, preferably with a small margin. If any embedded primitives and/or points do not lie in the interior of the simulated tetrahedron mesh, the Solid Object will display a warning. In addition, a primitive group `fe_outlier_primitives` and a point group `fe_outlier_points` may be generated on the Embedded Geometry. These groups indicate where parts of the embedded geometry are not properly contained in tetrahedrons.

Advantages:
- Exact interpolation
- position, velocity, point/vertex normals

= Constraints =

- There are hard constraints and soft constraints:
Prefer soft constraints when possible

- Target Constraints: hard (pintoanimation) and soft (targetstiffness and targetdamping)

= Collisions =

The finite element solver supports two types of collisions:
surface-based collisions and volume-based collisions.
Surface-based collisions are collisions between geometry such as
tetrahedrons, polygons, polylines and particles.
Volume-based collisions involve collisions between primitive vertices
and signed distance fields (SDFs).

Surface-based collisions are the most accurate option.
Surface-based collisions in Houdini employ continuous collision detection.
This means that the solver follows the trajectory of vertices between
successive frames to determine whether at any time inbetween these frames objects may intersect.
Continuous collision detection helps to ensure that collisions between fast moving objects are processed by the solver.
Surface-based collisions are the only choice for geometry that is deforming over time.

Volume-based collisions are a cheaper option, which is less accurate for finite elements.
It should not be used with deforming or fast moving objects.
No continuous collision detection is performed for volume-based collisions.
Also, only vertices of a Solid Object collide against SDFs (not the edges or the interiors of faces).
Volume-based collisions are an efficient choice for large objects that are part of the scenery.

- Collision Controls on the Solid Object
 
= Character Animation

= Secondary Simulation

= Mixing Solid and Cloth

= Fracturing

To use fracturing, you must enable fracturing on the solver. Also, each object for which you want fracturing to occur, you need to enable fracturing. Fracturing allows the tetrahedrons of this object to break apart when impacted beyond the internal stress that is specified by the __Fracture threshold__.
The __Fracturing Threshold__ specifies the relative amount of stress in any direction above which dynamic fracturing may occur. This lets you control how quickly the object will break into pieces as a result of stresses inside the object.
Realistic objects should not have the same fracture threshold everywhere. To vary the fracture threshold locally, you can use a point attribute with the name `fracturethreshold` that acts as a local multiplier for the per-object fracture threshold. 
    
It is recommended that you use the primitive attribute `fracturepart` to assign integer numbers to clumps of tetrahedrons that should never be broken up into smaller pieces. Creating these clumps prevents individual tetrahedrons from breaking off. The Solid Fracture SOP can be a useful tool for creating this `fracturepart` attribute. You can create a `fracturepart` on the embedded geometry as well. This way, the fractured pieces in the simulated geometry and the embedded geometry can be properly matched. The Solid Fracture asset can help you to create such a 'fracturepart' attribute.

Solid Fracture

