<index> specifies the component position in multi-component attributes
such as vectors, colors, and arrays. For example, if the attribute is a
color, an index value of 0 returns the red component, 1 returns the
green component, and 2 returns the blue component.

{
abs
Returns the absolute value of the argument.

USAGE
  abs(<number>)

EXAMPLES

  > abs (-2.6)=2.6

}

{
acos
Returns the arc-cosine of the argument.

USAGE
  acos(<number>)

EXAMPLES

  > acos (0)=90

}

{
angvel
Returns the angular velocity required to rotate an object from one
orientation to another in a certain period of time.

USAGE
  angvel(<rot1>, <rot2>, <time>)

The original rotation is specified in rot1, and the destination rotation
in rot2. These values can be either a vector3 containing euler rotation
angles in degrees, or a vector4 containing a quaternion. The returned
angular velocity value is expressed in degrees per second, and
represents the shortest path between the two orientations.

EXAMPLES

  > angvel(vector3(0, 0, 0), vector3(90, 0, 0), 1)[0]=90

}

{
arclen

REPLACED BY
  - hou.Face.arcLength()

Returns the arc length of a curve between two U positions.

USAGE
  arclen(<surface_node>, <prim_num>, <ustart>, <ustop>)

<ustart> and <ustop> are unit values, defined in the [0, 1] interval.


NOTE
    the primitive must be either a NURBS, Bezier, or Polygon curve.

EXAMPLES

  > arclen("/obj/geo1/model1", 12, 0, 1)
    Computes the length of the entire curve whose index is 12.

RELATED

  * arclenD

  * surflen

  * normal

  * curvature

  * unituv

}

{
arclenD
Returns the arc length of a curve between two U positions and number of
divisions.

USAGE
  arclen(<surface_node>, <prim_num>, <ustart>, <ustop>, <divs>)

<ustart> and <ustop> are unit values, defined in the [0, 1] interval.

<divs> is the number of divisions to use when evaluating curves.


NOTE
    the primitive must be either a NURBS, Bezier, or Polygon curve.

EXAMPLES

  > arclenD("/obj/geo1/model1", 12, 0, 1, 20)
    Computes the length of the entire curve whose index is 12.

RELATED

  * arclen

  * surflen

  * normal

  * curvature

  * unituv

}

{
arg
Returns an argument from a list of HScript-style arguments.

USAGE
  arg(<line>, <argNum>)

This function extracts an argument from a line. The example below will
extract the time out of the date string returned by the system function.
arg is useful for extracting tokens from space delimited strings.

EXAMPLES

  > arg("This returns foobar from this sentence", 2)
    Returns the third word from the sentence: foobar.

  > arg (system("date"), 3)

    Returns the the fourth word from the date command. This is usually
    the system time, ie: 15:26:31.

  > arg("Quoting 'makes this one arg'", 1)

    Returns "makes this one arg" as the quoting has transformed that
    into a single token. Note the quotes are not present in the output.

RELATED

  * argc

}

{
argc
Returns the number of arguments in an HScript-style list of arguments.

USAGE
  argc(<line>)

Standard parsing is done, no variable expansion is done on the line.

EXAMPLES

  > argc("This has four arguments")
    Returns 4, as that is the number of space delimited words.

  > argc("Quoting 'makes this one arg'")

    Returns two as the quotes cause the last four words to count as a
    single word.

RELATED

  * arg

}

{
asin
Returns the arc-sine of the argument.

USAGE
  asin(<number>)

EXAMPLES

  > asin (.866025)=60

}

{
atan
Returns the arc-tangent of the argument.

USAGE
  atan(<number>)

EXAMPLES

  > atan (1.73205)=60

RELATED

  * atan2

}

{
atan2
Returns the arc-tangent of <y>/<x>.

USAGE
  atan2(<y>, <x>)

This is more stable than atan since it can use the signs of y and x to
determine the quadrant the angle is in. It also handles the case where x
is zero correctly, returning 90 or -90.

EXAMPLES

  > atan2(1, 0) = 90
  > atan2(0, 1) = 0
  > atan2(0, -1) = 180

}

{
atof
Converts a string to a float.

USAGE
  atof(<source>)

}

{
bbox

REPLACED BY
  - hou.Geometry.pointBoundingBox()
  - hou.Geometry.primBoundingBox()
  - hou.Geometry.boundingBox()

Returns bounding box information for a surface node.

USAGE
  bbox(<surface_node>, <type>)

The <type> can be one of D_XMIN, D_YMIN, D_ZMIN, D_XMAX, D_YMAX, D_ZMAX,
D_XSIZE, D_YSIZE, or D_ZSIZE for the corresponding values of the
bounding box.

RELATED

  * centroid

}

{
bezier

REPLACED BY
  - hou.bezier()

Channel segment function: Bezier interpoloation spline

USAGE
  bezier()

RELATED

  * spline

  * cubic

}

{
boneangle
Returns the angle at the joint between two bone objects.

USAGE
  boneangle(<bone1>, <bone2>)

}

{
ceil
Returns the smallest integer not less than the value passed in.

USAGE
  ceil()

RELATED

  * floor

  * round

  * int

  * trunc

  * frac

}

{
centroid
Returns centroid information for a surface node.

USAGE
  centroid(<surface_node>, <type>)

The <type> should be one of D_X, D_Y, or D_Z for the corresponding
components of the centroid.

> centroid("../sphere1", D_X)
> centroid("../sphere1", D_Y)
> centroid("../sphere1", D_Z)

NOTE
    The centroid is the center of the bounding box of the points, not
    the average position of the points.

RELATED

  * bbox

  * prim

}

{
ch

REPLACED BY
  - hou.Node.evalParm()
  - hou.Parm
  - hou.ParmTuple.eval()
  - hou.ch()
  - hou.evalParm()
  - hou.evalParmTuple()
  - hou.nodeBySessionId()
  - hou.node()
  - hou.nodes()
  - hou.parmTuple()
  - hou.parm()

Returns the value of a parameter.

OVERVIEW

    The ch family of functions gets the value of a parameter. This lets
    you make the values of certain parameters automatically identical to
    or relative to the value of other parameters.

    For example, if you have two Geometry object nodes named geo1 and
    geo2, you can make geo2 always be 2 units higher than geo by setting
    geo2's Translate Y parameter to:

  > ch("../geo1/ty") + 2

    Now when you move geo1, geo2's Y position will always be 2 units
    higher.

    Channel references let you create custom spare parameters and
    digital asset interfaces and have them control other nodes, by using
    channel references to have the nodes inside the subnetwork/asset
    reference the "interface" parameters at the higher level.

PATH ARGUMENT

    The first argument to the channel functions is a string _path_ to
    the parameter whose value you want to get.

    For parameters on the same node, you can just use the parameter's
    _internal name_. For example, in an object, you could make the
    object's X position always match the Y position by setting the
    Translate Y to the expression:

  > ch("ty")

    TIP
        You can find the internal name of a parameter in the tooltip
        when you hover the mouse over the parameter in the parameter
        editor.

    To get a parameter on a different node, you need to make a _path_ to
    the parameter, similar to UNIX directory paths.

    For example, to reference the ty parameter of a node named geo2 in
    the same network:

  > ch("../geo2/ty")

    To reference the tx parameter of the parent network node:

  > ch("../tx")

GETTING NUMBERS

    USAGES
      ch("path")
      Returns the _floating point_ value of the given parameter.

      For example, to get the Origin X of the font1 node:

    > ch("../font1/tx")
      chf("path", frame_num)
      Returns the floating point value of the given parameter, as
      computed at the given frame number.

      Getting a value from a future time requires cooking some or all of
      the scene up to that time, so this function is potentially
      expensive.

      For example, to get the Origin X of the font1 node from ten frames
      previous:

    > chf("../font1/text", $F - 10)
      cht("path", seconds)
      Returns the floating point value of the given parameter, as
      computed at the given time (in seconds).

      Getting a value from a future time requires cooking some or all of
      the scene up to that time, so this function is potentially
      expensive.

      For example, to get the Origin X of the font1 node from 2 seconds
      previous:

    > chf("../font1/text", $T - 2)

GETTING STRINGS

    USAGES
      chs("path")
      Returns the _string_ value of the given parameter.

      For example, to get the Text of the font1 node:

    > chs("../font1/text")
      chsraw("path")
      Returns the "raw" string value of the given parameter, without
      expanding quotes or variable names. For example, if the parameter
      contains an expression $F - 10, you will get the string "$F - 10"
      (instead of the computed value of the current frame minus ten).

GETTING A NODE PATH

    See chsop.

GETTING RAMP VALUES

    See chramp, chrampf, and chrampt.

TIPS

  * You can automatically create channel-references using the "Copy" and
    "Paste reference" commands on the parameter [RMB] right-click menu.

  * See linking parameter values for more information.

RELATED

  * chramp

  * chexist

}

{
chexist

REPLACED BY
  - hou.Node.parm()
  - hou.parmTuple()
  - hou.parm()

Returns 1 if the specified channel exists, 0 if it doesn't.

USAGE
  chexist(<channel_name>)

The chexist() function determines whether an _animation channel_ exists
on the given parameter. This means it checks if the parameter is
_animated_, not whether the parameter itself exists.

To check if a parameter exists, you can use python scripting:

> 
> def parm_exist(parmpath):
>     nodepath, parmname = os.path.split(parmpath)
>     node = hou.node(nodepath)
>     return node.parmTuple(parmname) != None

EXAMPLES

  > echo `chexist("/obj/geo1/tx")`

}

{
chexpr
Evaluates a channel with a new segment expression.

USAGE
  chexpr(<channel>, <new_expr_function>)

EXAMPLES

  > chexpr("/obj/null1/tx", "linear()")
  > chexpr("/obj/null1/tx", "$IT")
  > chexpr("/obj/null1/tx", "$OT")
  > chexpr("/obj/null1/tx", "$IV")
  > chexpr("/obj/null1/tx", "$OV")


NOTE
    This can be used to extract in and out segment values, slopes and
    acceleration using channel expression local variables.

RELATED

  * chexprf

  * chexprt

}

{
chexprf
Evaluates a channel with a new segment expression at a given frame.

USAGE
  chexprf(<channel>, <new_expr_function>, <frame>)

EXAMPLES

  > chexprf("/obj/null1/tx", "linear()", 10)
  > chexprf("/obj/null1/tx", "$IT", 10)
  > chexprf("/obj/null1/tx", "$OT", 10)
  > chexprf("/obj/null1/tx", "$IV", 10)
  > chexprf("/obj/null1/tx", "$OV", 10)


NOTE
    This can be used to extract in and out segment values, slopes and
    acceleration using channel expression local variables.

RELATED

  * chexpr

  * chexprt

}

{
chexprt
Evaluates a channel with a new segment expression at a given time.

USAGE
  chexprt(<channel>, <new_expr_function>, <time>)

EXAMPLES

  > chexprt("/obj/null1/tx", "linear()", 1.0)
  > chexprt("/obj/null1/tx", "$IT", 1.0)
  > chexprt("/obj/null1/tx", "$OT", 1.0)
  > chexprt("/obj/null1/tx", "$IV", 1.0)
  > chexprt("/obj/null1/tx", "$OV", 1.0)


NOTE
    This can be used to extract in and out segment values, slopes and
    acceleration using channel expression local variables.

RELATED

  * chexpr

  * chexprf

}

{
chf

REPLACED BY
  - hou.Parm

Evaluates a parameter at a given frame.

USAGE
  chf(<channel>, <frame>)

RELATED

  * ch

  * cht

  * chs

  * chsraw

}

{
chgroup
return a string containing all of the channels contained in a group.

USAGE
  chgroup(<group_name>)

EXAMPLES

    This is useful in the command language for traversing all channels
    in a group:

  > % foreach channel ( `chgroup("group_name")` ) % echo $channel is in group_name % end

}

{
chop

REPLACED BY
  - hou.ChopNode
  - hou.Track

Evaluates a channel within a CHOP at the current time.

USAGE
  chop(<channel>)

EXAMPLES

  > chop("/ch/ch1/wave1/chan1")

RELATED

  * chopi

  * chopt

  * chopf

  * chopstr

}

{
chopcf

REPLACED BY
  - hou.Track

Evaluates a channel within a CHOP at a given time.

USAGE
  chopcf(<CHOP>, <channel_index>, <frame>)

Evaluates the channel at index <channel_index> within the specified
<CHOP> at the specified <frame>.

EXAMPLES

  > chopcf("/ch/ch1/wave1", 0, 11)

RELATED

  * chopf

  * chopct

  * chopci

}

{
chopci

REPLACED BY
  - hou.Track

Evaluates a channel within a CHOP at a specified sample point.

USAGE
  chopci(<CHOP>, <channel_index>, <index>)

Evaluates the channel at index <channel_index> within the specified
<CHOP> at the specified sample <index>.

EXAMPLES

  > chopci("/ch/ch1/wave1", 0, 10)

RELATED

  * chopi

  * chopct

  * chopcf

}

{
chopct

REPLACED BY
  - hou.Track

Evaluates a channel within a CHOP at a specified time.

USAGE
  chopct(<CHOP>, <channel_index>, <time>)

Evaluates the channel at index <channel_index> within the specified
<CHOP> at the specified <time>.

EXAMPLES

  > chopct("/ch/ch1/wave1", 0, 0.5)

RELATED

  * chopt

  * chopcf

  * chopci

}

{
chope

REPLACED BY
  - hou.ChopNode

Returns the end index of the channels in a CHOP.

USAGE
  chope(<CHOP>)

EXAMPLES

  > chope("/ch/ch1/wave1")

RELATED

  * chops

  * chopl

  * chopn

  * chopr

}

{
chopf

REPLACED BY
  - hou.Track

Evaluates a channel within a CHOP with at a given frame.

USAGE
  chopf(<channel>, <frame>)

EXAMPLES

  > chopf("/ch/ch1/wave1/chan1", 1)

RELATED

  * chopi

  * chopt

  * chop

}

{
chopi

REPLACED BY
  - hou.Track

Evaluates a channel within a CHOP at a given sample point.

USAGE
  chopi(<channel>, <index>)

Evaluates the <channel> (within a CHOP) at the specified sample <index>.

EXAMPLES

  > chopi("/ch/ch1/wave1/chan1", 10)

RELATED

  * chopf

  * chopt

  * chop

}

{
chopl

REPLACED BY
  - hou.Track

Returns the length of the channels in a CHOP, in samples.

USAGE
  chopl(<CHOP>)

EXAMPLES

  > chopl("/ch/ch1/wave1")

RELATED

  * chops

  * chope

  * chopn

  * chopr

}

{
chopn

REPLACED BY
  - hou.ChopNode

Returns the number of data channels within a CHOP.

USAGE
  chopn(<CHOP>)

EXAMPLES

  > chopn("/ch/ch1/wave1")

RELATED

  * chops

  * chope

  * chopl

  * chopr

}

{
chopnames
Returns the names of all the data channels within a CHOP.

USAGE
  chopnames(<CHOP>)

EXAMPLES

  > chopnames("/ch/ch1/wave1")

RELATED

  * chops

  * chope

  * chopl

  * chopr

}

{
chopr

REPLACED BY
  - hou.ChopNode

Returns the sample rate of a CHOP.

USAGE
  chopr(<CHOP>)

EXAMPLES

  > chopr("/ch/ch1/wave1")

RELATED

  * chops

  * chope

  * chopl

  * chopn

}

{
chops

REPLACED BY
  - hou.ChopNode

Returns the start index of a CHOP.

USAGE
  chops(<CHOP>)

EXAMPLES

  > chops("/ch/ch1/wave1")

RELATED

  * chops

  * chope

  * chopl

  * chopn

  * chopr

}

{
chopstr

REPLACED BY
  - hou.Track

Returns the string value of a channel within a CHOP at the current time.

USAGE
  chopstr(<channel>)

EXAMPLES

  > chopstr("/ch/ch1/wave1/chan1")

RELATED

  * chop

  * chopf

  * chopt

  * chopi

}

{
chopt

REPLACED BY
  - hou.Track

Returns the value of a channel within a CHOP at a specified time.

USAGE
  chopt(<channel>, <time>)

EXAMPLES

  > chopt("/ch/ch1/wave1/chan1", 0.5)

RELATED

  * chopct

  * chopi

  * chopf

  * chopt

}

{
chramp

REPLACED BY
  - hou.ParmTuple.eval()
  - hou.evalParmTuple()
  - hou.parmTuple()

Returns the value of a ramp parameter at a specific position.

USAGE
  chramp(<ramp_path>, <position>, <component_index>)

<position> must be a value from 0 to 1.

<component_index> is the component of the evaluated value to return. For
color ramps, it must be either 0, 1, or 2. For single-valued ramps,
<component_index> must be 0.

EXAMPLES

    Return the second component of the evaluated ramp value at a
    position of 0.33:

  > chramp("/obj/geo1/popnet1/color1/rampcolor", 0.33, 1)

RELATED

  * chrampf

  * chrampt

  * ch

}

{
chrampf
Returns the value of a ramp parameter at a specific position and frame.

USAGE
  chrampf(<ramp_path>, <position>, <component_index>, <frame>)

<position> must be a value from 0 to 1.

<component_index> is the component of the evaluated value to return. For
color ramps, it must be either 0, 1, or 2. For single-valued ramps,
<component_index> must be 0.

EXAMPLES

    Return second component of the evaluated ramp value at a position of
    0.33 at frame 289:

  > chrampf("/obj/geo1/popnet1/color1/rampcolor", 0.33, 1, 289)

RELATED

  * chramp

  * chrampt

  * ch

}

{
chrampt
Returns the value of a ramp parameter at a specific position and time.

USAGE
  chrampf(<ramp_path>, <position>, <component_index>, <time>)

<position> must be a value from 0 to 1.

<component_index> is the component of the evaluated value to return. For
color ramps, it must be either 0, 1, or 2. For single-valued ramps,
<component_index> must be 0.

EXAMPLES

    Return second component of the evaluated ramp value at a position of
    0.33 at 12 seconds into the scene:

  > chrampf("/obj/geo1/popnet1/color1/rampcolor", 0.33, 1, 12)

RELATED

  * chramp

  * chrampf

  * ch

}

{
chs

REPLACED BY
  - hou.Node.evalParm()
  - hou.Parm
  - hou.ParmTuple.eval()
  - hou.ch()
  - hou.evalParm()
  - hou.evalParmTuple()
  - hou.nodeBySessionId()
  - hou.node()
  - hou.nodes()
  - hou.parmTuple()
  - hou.parm()

Evaluates the string value of a parameter at the current time.

USAGE
  chs(<channel>)

This is useful for evaluating filenames in parameters. The string will
be expanded automatically.

RELATED

  * ch

  * chf

  * cht

  * chsop

  * chsraw

}

{
chsop

REPLACED BY
  - hou.Node.node()
  - hou.chsop()
  - hou.nodeBySessionId()
  - hou.node()
  - hou.nodes()

Evaluates the parameter at the current time as a node path string.

USAGE
  chsop("path")

Assumes the given parameter contains a node path, and automatically
takes care of things like bundles and relative paths, returning a string
containing an absolute path or a space-separated list of absolute paths.

For example, to get the Object node path used by the object_merge1 node:

> chsop("../object_merge1/object1")

RELATED

  * ch

  * chf

  * chs

  * chsoplist

  * chsraw

  * cht

}

{
chsoplist

REPLACED BY
  - hou.chsoplist()
  - hou.nodeBySessionId()

Evaluates the parameter at the current time as a node path list string.

USAGE
  chsoplist("path")

Assumes the given parameter contains a list of node paths, and
automatically takes care of things like bundles and relative paths,
returning a string containing an absolute path or a space-separated list
of absolute paths. It can also expand adhoc bundle strings like
/obj/null*.

For example, to get the Object node path used by the object_merge1 node:

> chsoplist("../object_merge1/object1")

RELATED

  * ch

  * chf

  * chsop

  * chs

  * chsraw

  * cht

  * oplistsort

}

{
chsraw

REPLACED BY
  - hou.BaseKeyframe
  - hou.Parm

Returns the raw (unexpanded) expression value of a parameter as a
string.

USAGE
  chsraw(<channel>)

Variables will NOT be expanded. If the given path is a channel, then it
returns the expression of the channel that is evaluated at the current
time.

If you do:

> echo `chsraw("channel_path")`

...this will appear to lose your formatting because hscript expands
double quotes before passing the result of the backtick expression to
the echo command. Multiple levels of escaping is necessary in order to
maintain them.

RELATED

  * ch

  * chf

  * chs

  * chsop

  * chsoplist

  * cht

}

{
cht

REPLACED BY
  - hou.Parm

Returns the value of a parameter at a specified time.

USAGE
  cht(<channel>, <time>)

RELATED

  * ch

  * chf

  * chs

  * chsraw

}

{
clamp

REPLACED BY
  - hou.hmath.clamp()

Returns a value clamped between a minimum and maximum.

USAGE
  clamp(<value>, <minimum>, <maximum>)

This is useful to prevent the value from going outside the specified
range.

If the value is less than the minimum number, the minimum number will be
returned. If the value is greater than the maximum number, the maximum
number will be returned.

}

{
clamptosphere
Clamps a vector to always end between a minimum and maximum sphere.

USAGE
  `clamptosphere(<x>, <y>, <z>, <min_radius>, <max_radius>,
  <constant_type>)`

This function computes a vector R that is parallel to the given (x,y,z)
vector. R is adjusted so that its magnitude is always between the min
and max radii (i.e min_radius <= |R| <= max_radius)

This function returns one of the components of the vector R according to
the value of <constant_type>: "X", "Y" or "Z".

}

{
constant

REPLACED BY
  - hou.constant()

Channel segment function: constant value.

USAGE
  constant()

RELATED

  * linear

}

{
contextoption
Returns a cook context option as a floating point value.

USAGE
  contextoption(<token>)

Retrieves the current value of a cook context option. This may have been
set by a node requesting data from another node, or from the global
default context option values stored in the hip file.

This function retrieves floating-point number values. For string values,
use contextoption.

  * <token>: the name of the option to retrieve.

}

{
contextoption
Returns a cook context option as a string value.

USAGE
  contextoptions(<token>)

Retrieves the current value of a cook context option. This may have been
set by a node requesting data from another node, or from the global
default context option values stored in the hip file.

This function retrieves string values. For floating-point number values,
use contextoption.

  * <token>: the name of the option to retrieve.

}

{
cophasmeta
Tests if metadata exists on a compositing node.

USAGE
  cophasmeta(<compositing_node>, <metadata_name>)

Metadata can be added to sequences with a Metadata COP. This expression
function queries if the metadata with metadata_name exists on the COP
node composting_node.

RELATED

  * copmeta

  * copmeta

}

{
copmeta

REPLACED BY
  - hou.CopNode

Returns numeric metadata from a compositing node.

USAGE
  copmeta(<compositing_node>, <metadata_name>, <index>)

Metadata can be added to sequences with a Metadata COP. This expression
function will return the value of numeric metadata, such as floating
point values, vectors, and matrices. The index is used to access the
element to return for types with multiple values, such as vector and
matrix types.

RELATED

  * copmeta

  * cophasmeta

}

{
copmeta

REPLACED BY
  - hou.CopNode

Returns string metadata from a compositing node.

USAGE
  copmetas(<compositing_node>, <metadata_name>)

Metadata can be added to sequences with a Metadata COP. This expression
function will return the value of string (text) metadata

RELATED

  * copmeta

  * cophasmeta

}

{
cos
Returns the cosine of the argument.

USAGE
  cos(<degrees>)

EXAMPLES

  > cos (60)=0.5

}

{
cosh
Returns the hyperbolic cosine of the argument.

USAGE
  cosh(<number>)

EXAMPLES

  > cosh (2) = 3.7622

}

{
cross

REPLACED BY
  - hou.Vector3.cross()

Computes the cross-product of two vectors.

USAGE
  cross(<v1>, <v2>)

}

{
cubic

REPLACED BY
  - hou.cubic()

Channel segment function: cubic spline.

USAGE
  cubic()

This function uses the slopes at either end to solve the differential
equation to give a smooth curve between the end points.

RELATED

  * spline

  * bezier

}

{
cucwc
Deprecated: current working container for custom panels.

Custom panels are deprecated functionality.

USAGE
  cucwc()

}

{
cudatatype
Deprecated: data type of a gadget, for custom panels.

USAGE
  cudatatype(<gadget_path>)

Possible values are float, int, and string.

Custom panels are deprecated functionality.

}

{
cumenuadd
Deprecated: adds a menu entry on a custom panel.

USAGE
  cumenuadd(<gadget_path>, <menu_entry>)

Adds the specified menu entry to the given gadget if it is a menu.
Returns the entry if added.

Custom panels are deprecated functionality.

}

{
cuquery
Deprecated: returns a value from a custom panel.

USAGE
  cuquery(<panel_path>, <value_name>)

Custom panels are deprecated functionality.

}

{
curvature
Returns the curvature of the surface at the given UV coordinates.

USAGE
  curvature(<surface_node>, <prim_num>, <u>, <v>)

<u> and <v> are unit values, defined in the [0, 1] interval.


NOTE
    if the primitive is a mesh, u and v are defined in terms of its
    number of rows and columns.

RELATED

  * unituv

  * primuv

  * primduv

  * normal

}

{
cutype
Deprecated: Returns the type of a gadget on a custom panel.

USAGE
  cutype(<gadget_path>)

Custom panels are deprecated functionality.

}

{
cycle

REPLACED BY
  - hou.cycle()

Channel segment function: repeats animation from previous frames.

USAGE
  cycle(<f1>, <f2>)

Repeats the animation from frames <f1> to <f2>.

If you wish to repeat the animation cumulatively, use the cycleoffset
function instead.

RELATED

  * cyclet

  * cycleoffset

  * cycleoffsett

}

{
cycleoffset

REPLACED BY
  - hou.cycleoffset()

Channel segment function: repeats the animation between frames <f1> and
<f2>, accumulating the value.

USAGE
  cycleoffset(<f1>, <f2>)

Each repeated portion will have its first value set to the last value of
the previous cycle. The rest of the values are set such that their
relative increments with respect to the first value match the relative
increments in the channel interval between <f1> and <f2>. If you wish to
repeat motion exactly, use the cycle function instead.

If <f1> is less than <f2>, then it will cycle forwards from <f1> to
<f2>. If <f2> is less than <f1>, then it will cycle backwards from <f2>
to <f1>.

RELATED

  * cycle

  * cyclet

  * cycleoffsett

}

{
cycleoffsett

REPLACED BY
  - hou.cycleoffsett()

Channel segment function: repeats the animation between times <t1> and
<t2>, accumulating the value.

USAGE
  cycleoffsett(<t1>, <t2>)

Each repeated portion will have its first value set to the last value of
the previous cycle. If you wish to repeat motion exactly, use the cyclet
function instead.

If <t1> is less than <t2>, then it will cycle forwards from <t1> to
<t2>. If <t2> is less than <t1>, then it will cycle backwards from <t2>
to <t1>.

RELATED

  * cycle

  * cyclet

  * cycleoffset

}

{
cyclet

REPLACED BY
  - hou.cyclet()

Channel segment function: repeats animation from previous frames.

USAGE
  cyclet(<t1>, <t2>)

Repeats the animation from <t1> seconds to <t2> seconds.

If you wish to repeat the animation cumulatively, use the cycleoffsett
function instead.

RELATED

  * cycle

  * cycleoffset

  * cycleoffsett

}

{
decode
Decodes a variable or geometry attribute name that was previously
encoded.

USAGE
  decode(<s>)

Houdini geometry attributes and group names are only allowed to contain
letters, numbers, and underscores, and must not begin with a number.
Arbitrary strings can be passed through the encode method to generate a
string that obeys these restriction. This method takes one of these
encoded strings, and returns the original string. A string that has not
been encoded will be returned unmodified.

RELATED

  * encode

}

{
deg

REPLACED BY
  - hou.hmath.radToDeg()

Converts from radians to degrees.

USAGE
  deg(<radians>)

}

{
degree
Returns the degree a specified face or hull.

USAGE
  degree(<surface_node>, <prim_num>, D_U|D_V)

Polygons and meshes are expressed as linear functions, so their degree
is 1. Spline types -- NURBS and Bezier curves and surfaces -- have
degrees ranging from 1 to 10.


NOTE
    If the primitive is a polygon or a curve, D_U and D_V are
    irrelevant.

}

{
detail

REPLACED BY
  - hou.Geometry.attribValue()

Returns the value of a detail attribute.

USAGE
  detail(<surface_node>, <attrib_name>, <attrib_index>)


TIP
    This expression may not work if <surface_node> is the _currently
    cooking_ node. Try specifying an upstream node.

This can also be used to read the value of a detail intrinsic by
specifying "intrinsic:name_of_intrinsic" instead of an attribute name.

EXAMPLES

  > detail("/obj/geo1/attribpromote1", "area", 0)
    Returns the total area of the geometry, if the geometry had first
    been measured and then AttribPromote had promoted the area primitive
    attribute to a detail attribute with Sum as the promotion method.

}

{
detailattribsize

REPLACED BY
  - hou.Geometry.attribValue()

Returns the number of components in a detail attribute.

USAGE
  detailattribsize(<surface_node>, <attribute>)

If the surface node or attribute is not found, returns 0.

EXAMPLES

  > detailattribsize( "/obj/model/capture", "pCaptData" )
    Returns the number of elements in a "pCaptData" attribute.

RELATED

  * detail

  * pointattribsize

  * vertexattribsize

  * primattribsize

}

{
detailattribtype
Returns the type of a detail attribute.

USAGE
  detailattribtype(<surface_node>, <attribute>)

If the surface node or attribute are not found, returns -1.


Types are
  * -1 - Unknown/Invalid

  * 0 - Integer

  * 1 - Float

  * 2 - String

EXAMPLES

  > detailattribsize( "/obj/model/box", "Cd" )
    Returns 1 to denote a float attribute.

RELATED

  * detail

  * pointattribtype

  * vertexattribtype

  * primattribtype

}

{
details

REPLACED BY
  - hou.Geometry.attribValue()

Returns the string value of a detail attribute.

USAGE
  details(<surface_node>, <attribute>)

This can also be used to read the value of a detail intrinsic by
specifying "intrinsic:name_of_intrinsic" instead of an attribute name.

EXAMPLES

  > details("/obj/geo1/attribcreate1", "varmap")
    Returns the currently bound index attribute's value.

}

{
detailsmap
Returns a string from a list of strings in a detail attribute.

USAGE
  detailsmap(<surface_node>, <attribute>, <index>)

This function will return the <index>th unique string bound to the given
detail attribute. Use detailsnummap to find the total number of unique
strings. Note that the exact order of the strings should not be relied
upon. The indexes start with 0 and go to detailsnummap()-1.

EXAMPLES

  > detailsmap("/obj/geo1/attribcreate1", "varmap", 0)
    Returns the first variable mappings on the given surface node.

}

{
detailsnummap
Returns the number of unique stings bound to a detail attribute.

USAGE
  detailsnummap(<surface_node>, <attribute>)

Use detailsmap to extract the strings.

EXAMPLES

  > detailsnummap("/obj/geo1/attribcreate1", "varmap")
    Returns number of variable mappings on the given surface node.

}

{
determinant

REPLACED BY
  - hou.Matrix4.determinant()

Returns the determinant of a matrix.

USAGE
  determinant(<mat>)

This is only valid for a 4x4 or 3x3 matrix. If the matrix is larger than
4x4, the 4x4 determinant will be returned. If the matrix is smaller than
3x3, the matrix will be converted to a 3x3 before the determinant is
computed. The results of the upward conversion are not guaranteed.

}

{
dihedral

REPLACED BY
  - hou.Vector3.matrixToRotateTo()

Computes the dihedral matrix between vectors <v0> and <v1>.

USAGE
  dihedral(<v0>, <v1>)

This returns a rotation matrix which will rotate vector v0 to vector v1.

}

{
distance

REPLACED BY
  - hou.Vector3.distanceTo()

Returns the distance between two 3D points.

USAGE
  distance(<x1>, <y1>, <z1>, <x2>, <y2>, <z2>)

A.K.A. sqrt((x2-x1)^2 + (y2-y1)^2 + (z2-z1)^2).

RELATED

  * pointdist

  * uvdist

}

{
dopallfields

REPLACED BY
  - hou.DopRecord.fieldNames()

Returns a space separated list of all the field names that can be passed
to the dopfield function.

USAGE
  `dopallfields(<dop>, <objectSpec>, <subDataName>,
  <recordType>)`

This list is not the same as the values returned from the dopfieldname
function because it includes all the subvalues that can be accessed. For
example if there is a vector field named "t", the dopfieldname function
would simply return "t". This function would return "tx ty tz" (along
with all the other field names). Note that "t" is not even in this list
because dopfield returns a single float value and so cannot access a
vector like "t" directly.

EXAMPLES

  > dopallfields("/obj/dopnet1", "obj0", "Position", "Options")
    Returns all the field name values that can be passed to the dopfield
    function. This list would begin "angvelx angvely angvelz ...".

RELATED

  * dopfield

}

{
dopcontextgeo
Returns the full path of the node connected to a dopnetwork.

USAGE
  dopcontextgeo(<name>, <index>)

<index> is the 0-based number of the input. For example, to get the path
of the node connected to the first input, use dopcontextgeo(".", 0), and
for the second input, use dopcontextgeo(".", 1).

This differs from opinputpath as the given name should be the name of a
node inside a dopnet (or the dopnet itself). This simplifies the process
of finding what is wired up to a dopnet node at the SOP level. Passing
"." as the path will cause your containing dopnet to be used.

EXAMPLES

  > point(dopcontextgeo(".", 0), $PT, "P", 0)

RELATED

  * opinput

  * opinputpath

  * opninputs

  * opoutput

  * opoutputpath

  * opnoutputs

}

{
dopcountslices
Returns the number of records of a given type in a piece of dynamics
data.

USAGE
  dopcountslices(<dop>, <objectFilter>, <subDataName>)
  Returns the number of slices an object should be broken into given the
  set of slices stored in the given data name. Each slice divides space
  into two, but the hierarchy of slices can make computation of the
  total more tricky, hence this function.

EXAMPLES

  > dopnumrecords("/obj/dopnet1", "object1", "Slice")
    Returns the number of logical slices object1 should be broken into
    given the slice data stored as subdata to Slice.

}

{
dopfield

REPLACED BY
  - hou.DopData.record()
  - hou.DopRecord.field()

Returns the value of a field as a float.

USAGE
  `dopfield(<dop>, <objectSpec>, <subDataName>, <recordType>,
  <recordNum>, <fieldName>)`

This function always returns a float value. To get a string value (which
you can possibly then convert to a different type, using for example
vector), see dopfields.

If a field is multivalued, you can access individual parameters by
adding a suffix.

For example, "ty" will access the y component of the "t" field. If the
field is a quaternion, you can use "rx", "ry", and "rz" as extensions to
get the euler rotations for the quaternion. In the special case of a
quaternion named "orient", simply using the name "rx" will return the
equivalent of "orientrx".

When accessing _subdata_, the name of the data field is based on the
name of the node that creates it. The complete path to the subdata must
be provided. See the example below.

EXAMPLES

  > dopfield("/obj/dopnet1", "obj0", "Position", "Options", 0, "ty")
    Returns the y position of object obj0

  > dopfield("/obj/dopnet1", "obj0", "Position", "Options", 0, "ry")

    Returns the ry component of the orientation of object obj0. This
    will be in degrees.

  > dopfield("/obj/geo1/dopnet1", "Relationships/Spring_spring_constraint1", "", "Basic", 0, "memusage")

    Returns the memory usage of a dynamics relationship

  > dopfield("/obj/dopnet1", "obj0", "Forces/Gravity_gravity1", "Options", 0, "forcey")

    Returns the y component of the gravity force created by the Gravity
    Force node named gravity1. Note that the full path must be given,
    including the relevant node name, and that this path corresponds to
    the folder names in the tree view of the DOP network.

RELATED

  * dopfields

}

{
dopfieldname

REPLACED BY
  - hou.DopRecord.fieldNames()

Returns the name of a DOP field.

USAGE
  `dopfieldname(<dop>, <objectSpec>, <subDataName>,
  <recordType>, <fieldNum>)`

Returns the name of the <fieldNum>th field of the given record type.

EXAMPLES

  > dopfieldname("/obj/dopnet1", "obj0", "Position", "Options", 3)
    Returns the name of the fourth field of the Options record of the
    Position subdata owned by obj0.

}

{
dopfields

REPLACED BY
  - hou.DopRecord.field()

Returns the value of a DOP field as a string.

USAGE
  dopfields(<dop>, <objectSpec>, <subDataName>, <recordType>,
  <recordNum>, <fieldName>)

Since this function returns values as a string, it allows you to convert
complex types such as vectors to the native type using the vector
expression function.

See dopfield for more information.

EXAMPLES

  > vector(dopfields("/obj/dopnet1", "obj0", "Position", "Options", 0, "position"))
    Gets the position of the object as a string and converts it into a
    vector.

  > dopfields("/obj/geo1/dopnet1", "Relationships/Spring_spring_constraint1", "", "ObjInGroup", 0, "objname")

    Returns the name of the first object involved in a spring constraint
    relationship (e.g. "sphere2").

  > dopfields("/obj/geo1/dopnet1","sphere2","", "RelInGroup", 0, "relname")

    Returns the name of the first relationship on an object (e.g.
    "Spring_spring_constraint1").

}

{
dopfieldtype

REPLACED BY
  - hou.DopRecord.fieldType()

Returns the type of a DOP field.

USAGE
  `dopfieldtype(<dop>, <objectSpec>, <subDataName>,
  <recordType>, <fieldNum>)`

Returns the type of the <fieldNum>th field of the given record.

Possible types are: "string", "float", "vector2", and "vector3".

EXAMPLES

  > dopfieldtype("/obj/dopnet1", "obj0", "Position", "Options", 2)
    Returns the type of the third field of the Options record of the
    Position data attached to object obj0.

}

{
dopframe
Returns the current frame of the simulation.

USAGE
  dopframe(<dop>)

This will often be equal to the global frame $F, unless the Time Scale
or Offset Time parameters of the DOP Network have been changed from
their default values.

RELATED

  * doptime

  * dopsttoframe

  * dopframetost

}

{
dopframetost
Returns the simulation time equivalent of a simulation frame.

USAGE
  dopframetost(<dop>, <simulationframe>)

RELATED

  * dopsttoframe

  * dopframe

}

{
dopgrouphasobject
Returns 1 if a specified DOP group contains a specified object.

USAGE
  dopgrouphasobject(<dop>, <objectSpec>, <group>)

EXAMPLES

  > dopgrouphasobject("/obj/dopnet1", "rbdobject", "group1")
    Returns 1 if group1 contains an object named rbdobject.

RELATED

  * dopgrouplist

}

{
dopgroupismutual
Returns 1 if a specified DOP group is mutually affecting.

USAGE
  dopgroupismutual(<dop>, <group>)

EXAMPLES

  > dopgroupismutual("/obj/dopnet1", "group1")
    Returns 1 if group1 is a mutual affector objects.

}

{
dopgrouplist
returns a string containing a list of all object groups for the current
time in a specified DOP Network.

USAGE
  dopgrouplist(<dop>)

EXAMPLES

  > dopgrouplist("/obj/dopnet1")
    Returns a string such as "group1 group2 rbdsolver1".

}

{
dophasfield

REPLACED BY
  - hou.DopRecord.fieldNames()
  - hou.DopRecord.fieldType()

Returns 1 if a specified DOP field exists.

USAGE
  `dophasfield(<dop>, <objectSpec>, <subDataName>,
  <recordType>, <recordNum>, <fieldName>)`

This expression can be used before the dopfield or dopfields expressions
to ensure that any returned empty strings or zero values are in fact
true values as opposed to default values being returned for an invalid
field name.

EXAMPLES

  > dophasfield("/obj/dopnet1", "obj0", "Position", "Options", 0, "ty")
    Returns 1, because Position data has an option with the name ty.

  > dopfield("/obj/dopnet1", "obj0", "Position", "Options", 0, "notafield")

    Returns 0 because notafield is not a field name in the Position data
    options.

}

{
dophassubdata

REPLACED BY
  - hou.DopData.findSubData()

Returns 1 if a dynamics object has the specified subdata.

USAGE
  dophassubdata(<dop>, <objectSpec>, <subDataName>)

EXAMPLES

  > dophassubdata("/obj/dopnet1", "obj0", "Geometry/Volume")
    Returns true if obj0's Geometry data has the Volume subdata attached
    to it.

}

{
dopnodeobjs

REPLACED BY
  - hou.DopObject.name()
  - hou.DopSimulation.objects()
  - hou.Node.findNodesThatProcessedObject()

Returns the list of objects processed by a DOP in the latest timestep.

USAGE
  dopnodeobjs(<dop>)

Returns a string containing a space-separated list of object identifies.

EXAMPLES

  > dopnodeobjs("/obj/dopnet1")
    Returns a list of identifiers for all objects in the /obj/dopnet1
    DOP Network. Since no specific DOP node is specified, the node with
    the display flag is used.

}

{
dopnumfields

REPLACED BY
  - hou.DopRecord.fieldNames()

Returns the number of fields in a DOP record type.

USAGE
  `dopnumfields(<dop>, <objectSpec>, <subDataName>,
  <recordType>)`

The "Options" record type, for example, usually has one field for every
parameter in the DOP Node that creates that data type.

EXAMPLES

  > dopnumfields("/obj/dopnet1", "obj0", "Position", "Options")
    Returns the number of different fields that the "Options" record has
    in the "Position" data owned by "obj0".

}

{
dopnumobjects

REPLACED BY
  - hou.DopSimulation.objects()

returns the number of objects in a simulation.

USAGE
  dopnumobjects(<dop>, <objectFilter>)

EXAMPLES

  > dopnumobjects("/obj/dopnet1", "foo*")
    Returns the number of objects in the dopnet with names prefixed by
    foo.

RELATED

  * dopobjectlist

}

{
dopnumrecords

REPLACED BY
  - hou.DopData.records()

Returns the number of records of a given type in a piece of dynamics
data.

USAGE
  `dopnumrecords(<dop>, <objectFilter>, <subDataName>,
  <recordType>)`

Note that this is different than the number of fields. The
Position/Options data type usually has one record that has several
fields, such as "position" and "orientation".

EXAMPLES

  > dopnumrecords("/obj/dopnet1", "object1", "Impacts", "Impacts")
    Returns the number of records in the record type called "Impacts"
    found in the data called "Impacts", which is owned by the object
    "object1"

}

{
dopnumrecordtypes

REPLACED BY
  - hou.DopData.recordTypes()

Returns the number of types of record in a piece of dynamics data.

USAGE
  dopnumrecordtypes(<dop>, <objectSpec>, <subDataName>)

Most subdata contains at least the records "Basic" and "Options"

EXAMPLES

  > dopnumrecordtypes("/obj/dopnet1", "object1", "Position")
    Returns the number of record types that the Position data attached
    to object1 has.

}

{
dopnumsubdata

REPLACED BY
  - hou.DopData.subData()

Returns the number of subdata items attached to an object or data.

USAGE
  dopnumsubdata(<dop>, <objectSpec>, <subDataName>)

EXAMPLES

  > dopnumsubdata("/obj/dopnet1", "obj0", "")
    Returns the number of data items attached to obj0.

  > dopnumsubdata("/obj/dopnet1", "obj0", "Geometry")

    Returns the number of data items attached to obj0/Geometry.

}

{
dopobjectlist

REPLACED BY
  - hou.DopSimulation.findAllObjects()

Returns all objects matching the an object specification.

USAGE
  dopobjectlist(<dop>, <objectSpec>, <listNames>)

Returns a string containing a space-separated list. If the <listNames>
argument is zero, then the string is a list of object identifiers.
Otherwise it is a list of object names.

Object names are easier to read, but may not uniquely identify each
object.

EXAMPLES

  > dopobjectlist("/obj/dopnet1", "obj? object*", 1)
    Returns a string such as "obj1 obj2 object1 objectfoo".

RELATED

  * dopnumobjects

}

{
dopobjectsareaffectors
Tests whether a set of objects has an affector relationship with another
object.

USAGE
  dopobjectsareaffectors(<dop>, <objectSpec>, <affectors>)

Returns 1 if all the objects specified by the affectors argument are
affectors of the single object specified with the objectSpec argument.

EXAMPLES

  > dopobjectsareaffectors("/obj/dopnet1", "obj1", "obj2 obj3")
    Returns one if obj2 and obj3 are affectors of obj1.

}

{
dopobjscreatedby

REPLACED BY
  - hou.DopNode.createdObjects()

Returns the list of objects created by a particular DOP node.

USAGE
  dopobjscreatedby(<dop>)

Returns a string containing a space-separated list of object identifies.

EXAMPLES

  > dopobjscreatedby("/obj/dopnet1/rbdglueobject1")
    Returns a list of identifiers for all objects created by the
    rbdglueobject1 DOP node.

}

{
dopoption

REPLACED BY
  - hou.DopData.options()

Returns the value of a DOP field as a float.

USAGE
  `dopoption(<dop>, <objectSpec>, <subDataName>,
  <fieldName>)`

If a field is multivalued, you can access individual parameters by
adding a suffix.

For example, "positiony" will access the y component of the "position"
field. If the field is a quaternion, one can use "rx", "ry", and "rz" as
extensions to get the euler rotations for the quaternion.

This function is exactly the same as the dopfield function except the
fourth and fifth arguments are always "Options" and "0" respectively.

EXAMPLES

  > dopoption("/obj/dopnet1", "obj0", "Position", "ty")
    Returns the y position of object obj0

  > dopoption("/obj/dopnet1", "obj0", "Position", "ry")

    Returns the ry component of the orientation of object obj0. This
    will be in degrees.

}

{
dopoptions

REPLACED BY
  - hou.DopData.options()

Returns the value of a DOP field as a string.

USAGE
  `dopoptions(<dop>, <objectSpec>, <subDataName>,
  <fieldName>)`

This allows complex types such as vectors to be converted to the native
type using the vector expression.

This function is exactly the same as the dopfields function except the
fourth and fifth arguments are always "Options" and "0" respectively.

EXAMPLES

  > vector(dopoptions("/obj/dopnet1", "obj0", "Position", "position"))
    Gets the position of the object as a string and converts it into a
    vector.

}

{
doprecordtypename

REPLACED BY
  - hou.DopData.recordTypes()

Returns the name of a record in DOPs data given its index.

USAGE
  `doprecordtypename(<dop>, <objectSpec>, <subDataName>,
  <recordTypeNum>)`

Returns the name of the <recordTypeNum>th record that is owned by the
given subData.

EXAMPLES

  > doprecordtypename("/obj/dopnet1", "obj0", "Geometry/Volume", 0)
    Returns the name of the first record type of the Volume data which
    is attached to the Geometry data of obj0.

}

{
dopsolvedopnet

REPLACED BY
  - hou.dop.scriptSolverNetwork()
  - hou.dop.scriptSolverSimulation()

Script solver support function.

USAGE
  dopsolvedopnet()

This function returns the full path of the DOP Network that contains the
script solver that is currently running.

This is one of a set of expression functions for use by the Script
Solver DOP. Calling this function will return an empty string if it is
called when a script solver is not currently solving for objects.

RELATED

  * dopsolvenumobjects

  * dopsolveobject

  * dopsolvenumnewobjects

  * dopsolvenewobject

  * dopsolvetimestep

  * dopsolveadddata

  * dopsolveremovedata

  * dopsolvesetoption

  * Script Solver

}

{
dopsolvenewobject

REPLACED BY
  - hou.dop.scriptSolverNewObjects()

Script solver support function.

USAGE
  dopsolvenewobject(<object_index>)

This function is similar to dopsolveobject, except it returns the newly
created objects that need to be initialized from a script solver. The
object index must be greater than or equal to zero, and less than the
return value of dopsolvenumnewobjects.

EXAMPLES

  > set lastobject=`dopsolvenumnewobjects() - 1`
  > for i = 0 to $lastobject
  >     echo `dopsolvenewobject($i)`
  > end
    Outputs the unique object ids of all the objects being initialized
    by the current script solver.

RELATED

  * dopsolvenewobject

  * dopsolvenumobjects

  * dopsolvenumnewobjects

  * dopsolvedopnet

  * dopsolvetimestep

  * dopsolveadddata

  * dopsolveremovedata

  * dopsolvesetoption

  * Script Solver

}

{
dopsolvenumnewobjects

REPLACED BY
  - hou.dop.scriptSolverNewObjects()

Script solver support function.

USAGE
  dopsolvenumnewobjects()

Returns the number of objects being initialized by the script solver
that is currently running.

This is one of a set of expression functions for use by the Script
Solver DOP. See dopsolveobject and dopsolvenumobjects for more
information.

RELATED

  * dopsolvenumnewobjects

  * dopsolveobject

  * dopsolvenewobject

  * dopsolvedopnet

  * dopsolvetimestep

  * dopsolveadddata

  * dopsolveremovedata

  * dopsolvesetoption

  * Script Solver

}

{
dopsolvenumobjects

REPLACED BY
  - hou.dop.scriptSolverObjects()

Script solver support function.

USAGE
  dopsolvenumobjects()

Returns the number of objects being solved by the script solver that is
currently running. Returns zero if it is called when a script solver is
not currently solving for objects.

This is one of a set of expression functions for use by the Script
Solver DOP.

RELATED

  * dopsolvenumnewobjects

  * dopsolveobject

  * dopsolvenewobject

  * dopsolvedopnet

  * dopsolvetimestep

  * dopsolveadddata

  * dopsolveremovedata

  * dopsolvesetoption

  * Script Solver

}

{
dopsolveobject

REPLACED BY
  - hou.dop.scriptSolverObjects()

Script solver support function.

USAGE
  dopsolveobject(<object_index>)

This function returns the unique object identifier for the specified
object. The object is specified as a number greater than or equal to
zero, and less than the return value of dopsolvenumobjects. This
function is required to get an object id to use in other DOP expression
function for getting data about the objects being solved by the script
solver.

This is one of a set of expression functions for use by the Script
Solver DOP. Calling this function will return -1 if it is called when a
script solver is not currently solving for objects.

EXAMPLES

  > set lastobject=`dopsolvenumobjects() - 1`
  > for i = 0 to $lastobject
  >     echo `dopsolveobject($i)`
  > end
    Outputs the unique object ids of all the objects being solved by the
    current script solver.

RELATED

  * dopsolvenewobject

  * dopsolvenumobjects

  * dopsolvenumnewobjects

  * dopsolvedopnet

  * dopsolvetimestep

  * dopsolveadddata

  * dopsolveremovedata

  * dopsolvesetoption

  * Script Solver

}

{
dopsolvetimestep

REPLACED BY
  - hou.dop.scriptSolverTimestepSize()

Script solver support function.

USAGE
  dopsolvetimestep()

Returns the timestep size for the script solver that is currently
running.

This is one of a set of expression functions for use by the Script
Solver DOP. Calling this function will return zero if it is called when
a script solver is not currently solving for objects.

RELATED

  * dopsolvenumobjects

  * dopsolveobject

  * dopsolvenumnewobjects

  * dopsolvenewobject

  * dopsolvedopnet

  * dopsolveadddata

  * dopsolveremovedata

  * dopsolvesetoption

  * Script Solver

}

{
dopsttoframe
returns the simulation frame of a given simulation time.

USAGE
  dopsttoframe(<dop>, <simulationtime>)

RELATED

  * dopframe

  * dopframetost

}

{
dopsttot
Returns the global time of a given simulation time.

USAGE
  dopsttot(<dop>, <simulationtime>)

RELATED

  * doptime

  * dopttost

}

{
dopsubdataname

REPLACED BY
  - hou.DopData.subData()

Returns the name of a subdata of a given DOP object.

USAGE
  `dopsubdataname(<dop>, <objectSpec>, <subDataName>,
  <subDataNum>)`

EXAMPLES

  > dopsubdataname("/obj/dopnet1", "foobar", "", 0)
    Returns the name of the first data attached to the object foobar.

  > dopsubdataname("/obj/dopnet1", "foobar", "Geometry", 3)

    Returns the name of the 4th subdata attached to the object foobar's
    data "Geometry".

}

{
doptime

REPLACED BY
  - hou.DopSimulation.time()

Returns the current time of a simulation.

USAGE
  doptime(<dop>)

This will often be equal to the global time $T, unless the Time Scale or
Offset Time parameters of the DOP Network have been changed from their
default values.

RELATED

  * dopframe

  * dopsttot

  * dopttost

}

{
doptransform

REPLACED BY
  - hou.DopObject.transform()

Returns a transformation matrix associated with a piece of data.

USAGE
  doptransform(<dop>, <objectSpec>, <subDataName>)

The data must be either Position data or Geometry data. For Geometry
data, if the data name is "Geometry", then the transform for any
Position data attached to the object is also applied. Thus this function
can be used to transform a point position from the space of the raw
geometry to simulation space.

EXAMPLES

  > doptransform("/obj/dopnet1", "obj0", "Geometry")
    Returns a matrix which is the product of the transform in the
    Geometry data multiplied by the transform of any Position data on
    the object.

}

{
dopttost
Returns the simulation time equivalent to a given global time.

USAGE
  dopttost(<dop>, <globaltime>)

This is similar to the doptime expression except for the ability to
specify a global time other than the current time.

RELATED

  * dopsttot

  * doptime

}

{
dopvelatpos
Returns the velocity that a point at a location in simulation space
would have if it were attached to a DOP object.

USAGE
  `dopvelatpos(<dop>, <objectSpec>, <posx>, <posy>, <posz>,
  <usevolumevelocity>, <usepointvelocity>)`

This velocity calculation takes into account the velocity and angular
velocity of the simulation object as stored in its Position data.

Setting the usevolumevelocity argument to a non-zero value causes the
returned velocity to be affected by a geometry space velocity calculated
from changes in the volumetric representation of the geometry.

Setting the usepointvelocity argument to a non-zero value causes the
returned velocity to be affected by the velocity attribute on the
geometry for the object. The geometry velocity attribute is added to the
result as a geometry space velocity which is added to the velocity from
the Position data. If both usedsdfvelocity and usepointvelocity are non-
zero, then the sdf velocity is used, not the point velocity.

EXAMPLES

  > dopvelatpos("/obj/dopnet1", "obj0", point("/obj/dopnet1:obj0/Geometry", 0, "P", 0), point("/obj/dopnet1:obj0/Geometry", 0, "P", 1), point("/obj/dopnet1:obj0/Geometry", 0, "P", 2), 1, 0)
    Returns the simulation space velocity of point 0 of the geometry
    attached to obj0, taking into account any velocity attribute on the
    geometry.

}

{
dot

REPLACED BY
  - hou.Vector3.dot()

Computes the dot product of two vectors.

USAGE
  dot(<v0>, <v1>)

}

{
ease

REPLACED BY
  - hou.ease()

Channel segment function: ease-in and -out.

USAGE
  ease()

Starts at rest and slowly increases the amount of change, and then, near
the end of the function, gradually reduces the rate of change until it
is at rest.

RELATED

  * easep

  * easein

  * easeout

}

{
easein

REPLACED BY
  - hou.easein()

Channel segment function: ease-in.

USAGE
  easein()

Will slowly ease in to any change.

RELATED

  * easeinp

  * ease

  * easeout

}

{
easeinp

REPLACED BY
  - hou.easeinp()

Channel segment function: ease-in with configurable acceleration.

USAGE
  easeinp(<number>)

Slowly increases the motion of the model to its maximum value. This is
similar to the motion of an object accelerating due to gravity. The
<number> controls how fast to ease into the motion: a large value
defines a high speed at the end of the segment.

EXAMPLES

  > easeinp( 10 )
    Eases in with a fairly big final velocity.

RELATED

  * easein

  * easep

  * easeoutp

}

{
easeout

REPLACED BY
  - hou.easeout()

Channel segment function: ease-out

USAGE
  easeout()

Slowly eases out of any change and comes to rest.

RELATED

  * easeoutp

  * ease

  * easein

}

{
easeoutp

REPLACED BY
  - hou.easeoutp()

Channel segment function: ease-out with configurable acceleration.

USAGE
  easeoutp(<number>)

Similar to the easeinp expression only reversed. The change starts
rapidly and begins to slow until it comes to rest. The <number>
determines the speed (i.e., the rate of channel change) at the beginning
of the segment. A large value defines a high speed.

EXAMPLES

  > easeoutp( 3 )
    Eases out of a fairly high initial speed.

RELATED

  * easeout

  * easep

  * easeinp

}

{
easep

REPLACED BY
  - hou.easep()

Channel segment function: ease-in and -out with configurable
acceleration.

USAGE
  easep(<number>)

This is a channel expression function which will gradually ease in to
the motion and gradually ease out. The <number> controls how fast to
ease in or out. Mathematically, this argument determines the inflection
point of the curve. Increasing the number will shift the inflection
point to the right, while fractional numbers will towards zero will
shift the inflection point to the right.

EXAMPLES

  > easep( 3 )
    Eases in slowly and eases out quickly.

  > easep( 0.4 )

    Eases in quickly and eases out slowly.

RELATED

  * ease

  * easeinp

  * easeoutp

}

{
edgegrouplist
Returns the list of edge groups in a surface node.

USAGE
  edgegrouplist(<surface_node>)

The returned string is a space separated list of group names.

To get a list of groups whose names match a pattern, use edgegroupmask.

RELATED

  * primgrouplist

  * pointgrouplist

  * edgegroupmask

}

{
edgegroupmask
Returns the list of edge groups matching a pattern in a surface node.

USAGE
  edgegroupmask(<surface_node>, <pattern>)

The returned string is a space separated list of group names.

To simply get a list of all edge groups (no pattern), use edgegrouplist.

EXAMPLES

  > edgegroupmask("/obj/model", "group*")
    Returns the names of all edge groups in the specified surface node
    which start with "group". So this may be something like "group1
    group2 group_smoke".

RELATED

  * primgroupmask

  * pointgroupmask

  * edgegrouplist

}

{
encode
Encodes any string into a valid variable or geometry attribute name.

USAGE
  encode(<s>)

Houdini geometry attributes and group names are only allowed to contain
letters, numbers, and underscores, and must not begin with a number.
This method takes any string, and encodes it into a string that obeys
these restrictions. The original string can be recovered using the
decode method. A string that already obeys the rules is returned
unmodified.

One exception to this rule is that a string starting with xn__ will be
encoded even if it is already a valid attribute name. This is because
xn__ is the prefix used to identify an encoded string. In this case, an
additional xn__ prefix will be added. This means a string can be encoded
any number of times, then decoded the same number of times to always
return to the original string, regardless of its contents.

RELATED

  * decode

}

{
eval
Evaulates a string as an expression returning a float.

USAGE
  eval(<expression>)

Useful for evaluating variables which contain more complex expressions.
Returns a floating point value.

EXAMPLES

  > set foo = 1+2 echo `eval($foo)`

}

{
evals
Evaulates a string as an expression returning a string.

USAGE
  evals(<expression>)

Useful for evaluating variables which contain more complex expressions.
This function returns a string value.

EXAMPLES

  > set foo = system("ls") echo `evals($foo)`

}

{
execute

REPLACED BY
  - hou.hscript()

Runs a string as an HScript command and returns the command's output.

USAGE
  execute(<command>)

Returns a string containing the regular output of the command, but not
the error output.

RELATED

  * executee

  * executeb

}

{
executeb
Runs a string as an HScript command and returns the command and error
output.

USAGE
  executeb(<command>)

Returns a string containing both the regular and error output of the
command, separated by ~~~~.

RELATED

  * execute

  * executee

}

{
executee
Runs a string as an HScript command and returns any error output.

USAGE
  executee(<command>)

Returns a string containing the error output of the command, but not the
regular output.

RELATED

  * execute

  * executeb

}

{
exp
Returns the logarithmic exponentiation of the argument.

USAGE
  exp(<number>)

EXAMPLES

  > exp (x)= $E^x
  > exp (2)= 7.3338906

}

{
explodematrix

REPLACED BY
  - hou.Matrix4.explode()

Explodes a 3x3 or 4x4 matrix into the euler rotations required to
rebuild it.

USAGE
  explodematrix(<mat>, <trs>, <xyz>, <component>)

The returned components can be stuffed directly into Houdini rotation,
scale, and translate channels.

If you know the pivot point for the transformation, you may want to use
the explodematrixp or explodematrixpr functions instead.

<mat> is the matrix to transform. <trs> and <xyz> give the order of the
expansion. In trs, a "t" represents translation, "r" rotation, and "s"
scale. The xyz refers to the order of the rotations. The component is a
string describing which channel to extract. It is [trs][xyz] (e.g. "tx"
or "ry"), where the t, r, or s chooses the channel (translate, rotate,
or scale), and the x, y, or z chooses the axis. Shears can be extracted
by specifying a component of "sh1", "sh2", or "sh3".

EXAMPLES

  > explodematrix(mlookat(vector("[1,0,0]"),vector("[0,1,0]")), "RST", "XYZ", "RZ")
  > explodematrix(identity(3)*2, "RST", "XYZ", "SZ")

}

{
explodematrixp
Explodes a 3x3 or 4x4 matrix into the euler rotations required to
rebuild it.

USAGE
  explodematrixp(<mat>, <p>, <trs>, <xyz>, <component>)

The returned components can be stuffed directly into Houdini rotation,
scale, and translate channels.

This expression is exactly like explodematrix, except it requires you to
specify a pivot position vector. This is useful if you know the pivot
position of the matrix being processed. Use explodematrixpr if you know
the pivot rotation of the matrix being processed.

<mat> is the matrix to transform. <trs> and <xyz> give the order of the
expansion. In trs, a "t" represents translation, "r" rotation, and "s"
scale. The xyz refers to the order of the rotations. The component is a
string describing which channel to extract. It is [trs][xyz] (e.g. "tx"
or "ry"), where the t, r, or s chooses the channel (translate, rotate,
or scale), and the x, y, or z chooses the axis. Shears can be extracted
by specifying a component of "sh1", "sh2", or "sh3".

EXAMPLES

  > explodematrixp(optransform("/obj/geo1"), vector3(ch("/obj/geo1/px"), ch("/obj/geo1/py"), ch("/obj/geo1/pz")), "RST", "XYZ", "RZ")

}

{
explodematrixpr
Explodes a 3x3 or 4x4 matrix into the euler rotations required to
rebuild it.

USAGE
  explodematrixp(<mat>, <p>, <trs>, <xyz>, <component>)

The returned components can be stuffed directly into Houdini rotation,
scale, and translate channels.

This expression is exactly like explodematrixp, except it allows you to
specify a pivot rotation. This is useful if you know the pivot rotation
in addition to the pivot position of the matrix being processed.

<mat> is the matrix to transform. <trs> and <xyz> give the order of the
expansion. In trs, a "t" represents translation, "r" rotation, and "s"
scale. The xyz refers to the order of the rotations. The component is a
string describing which channel to extract. It is [trs][xyz] (e.g. "tx"
or "ry"), where the t, r, or s chooses the channel (translate, rotate,
or scale), and the x, y, or z chooses the axis. Shears can be extracted
by specifying a component of "sh1", "sh2", or "sh3".

EXAMPLES

  > explodematrixpr(optransform("/obj/geo1"), vector3(ch("/obj/geo1/px"), ch("/obj/geo1/py"), ch("/obj/geo1/pz")), vector3(ch("/obj/geo1/prx"), ch("/obj/geo1"/pry), ch("/obj/geo1/prz")), "RST", "XYZ", "RZ")

}

{
findfile

REPLACED BY
  - hou.findFile()

Searches the Houdini path for a file.

USAGE
  findfile(<filename>)

The filename specified should be relative to one of the paths specified
in the HOUDINI_PATH environment variable.

EXAMPLES

  > findfile("scripts/123.cmd")
  > findfile("config/Audio/Error.aiff")

RELATED

  * findfiles

}

{
findfiles

REPLACED BY
  - hou.findFiles()
  - hou.findFilesWithExtension()

Searches the Houdini path for a file or directory.

USAGE
  findfiles(<filename>, <separator>)

Searches the houdini path for the specified file or directory, returning
a list of all the matches separated by the specified separator. It is
handy to use a separator of \\n when echoing the results. The filename
specified should be relative to one of the paths specified in the
HOUDINI_PATH environment variable.

EXAMPLES

  > findfiles("config", " ")

RELATED

  * findfile

}

{
fit

REPLACED BY
  - hou.hmath.fit()

Fits a value from one range to another.

USAGE
  fit(<num>, <oldmin>, <oldmax>, <newmin>, <newmax>)

Return a number between newmin and newmax that is relative to num in the
range between oldmin and oldmax. If the value is outside the old range,
it will be clamped to the new range.

EXAMPLES

  > fit(3,1,4,5,20)=15

RELATED

  * fit01

  * fit11

  * fit10

}

{
fit01

REPLACED BY
  - hou.hmath.fit01()

Fits a value to the 0-1 range.

USAGE
  fit01(<num>, <newmin>, <newmax>)

Returns a number between newmin and newmax that is relative to num in
the range between 0 and 1. If the value is outside the 0 to 1 it will be
clamped to the new range.

EXAMPLES

  > fit01(.3,5,20)=9.5

RELATED

  * fit

  * fit11

  * fit10

}

{
fit10

REPLACED BY
  - hou.hmath.fit10()

Fits a number in the 0-1 range.

USAGE
  fit10(<num>, <newmin>, <newmax>)

Return a number between newmin and newmax that is relative to num in the
range between 1 and 0. If the value is outside the 1 and 0 it will be
clamped to the new range.

EXAMPLES

  > fit(.3,5,20)=15.5

RELATED

  * fit

  * fit01

  * fit11

}

{
fit11

REPLACED BY
  - hou.hmath.fit11()

Fits a number to the -1 to 1 range.

USAGE
  fit11(<num>, <newmin>, <newmax>)

Return a number between newmin and newmax that is relative to num in the
range between -1 and 1. If the value is outside the -1 to 1 it will be
clamped to the new range.

EXAMPLES

  > fit(.3,5,20)=14.75

RELATED

  * fit

  * fit01

  * fit10

}

{
floor
Returns the largest integer not greater than a number.

USAGE
  floor(<number>)

EXAMPLES

  > floor(10.2)=10
  > floor(-10.2)=-11

RELATED

  * ceil

  * trunc

  * int

  * round

  * frac

}

{
frac
Returns the fractional part of a floating-point number.

USAGE
  frac(<number>)

The fractional component is computed using the expression (number -
floor(number)), which may result in unexpected values for negative
numbers. If negative numbers are an issue, you may want to call
frac(abs(number)).

EXAMPLES

  > frac(2.501) = 0.501

RELATED

  * trunc

  * floor

  * ceil

  * round

  * int

}

{
ftoa
Converts a number to a string.

USAGE
  ftoa(<number>)

Type conversion is usually done automatically. However, you may wish to
use this to force the conversion.

}

{
ftrim
Converts a number to a string.

USAGE
  ftrim(<number>)

Type conversion is usually done automatically. However, you may wish to
use this to force the conversion.

The ftrim() function will also round the number to 6 decimal digits of
precision, avoiding slightly off numbers caused by floating point not
being able to exactly represent common decimal numbers.

}

{
groupbyval
Returns a string describing the set of elements with a given value for
an integer attribute.

USAGE
  groupbyval(<surface_node>, <class>, <attribute>, <id>)

The <class> can be one of D_VERTEX,D_POINT, D_PRIMITIVE, or D_DETAIL for
the corresponding attribute class.

EXAMPLES

  > groupbyval("/obj/geo1/facet1", D_PRIMITIVE, "piece", 1)
    Returns a string describing the set of primitives with a value of 1
    for the piece attribute in the facet1 surface node in geo1.

}

{
groupbyvals
Returns a string describing the set of elements with a given value for a
string attribute.

USAGE
  groupbyvals(<surface_node>, <class>, <attribute>, <id>)

The <class> can be one of D_VERTEX, D_POINT, D_PRIMITIVE, or D_DETAIL
for the corresponding attribute class.

EXAMPLES

  > groupbyvals("/obj/geo1/facet1", D_PRIMITIVE, "name", "piece1")
    Returns a string describing the set of primitives with a value of
    piece1 for the name attribute in the facet1 surface node in geo1.

}

{
hascontextoption
Returns a non-zero value if the specified context option exists.

USAGE
  hascontextoption(<token>)

Checks if the provided context option exists in the current cook
context. This value may have been set by a node requesting data from
another node, or it may be set as a global default context option stored
in the hip file.

This function just tests if the context option exists. To get the value
of the context option use contextoption or contextoption.

  * <token>: the name of the option to check.

}

{
hasdetailattrib

REPLACED BY
  - hou.Geometry.findGlobalAttrib()

Returns 1 if a specified detail attribute exists.

USAGE
  hasdetailattrib(<surface_node>, <attribute>)

}

{
haspoint

REPLACED BY
  - hou.Geometry.iterPoints()
  - hou.PointGroup

Returns 1 if a specified point is in a specified group.

USAGE
  haspoint(<group_name>, <surface_node>, <point_num>)

The function will return 0 if the group is a primitive group.

EXAMPLES

  > haspoint("ears", "/obj/geo1/facet1", 4)
    Returns 1 if the group "ears" contains point number 4, otherwise
    returns 0.

RELATED

  * hasprim

  * pointlist

  * primlist

}

{
haspointattrib

REPLACED BY
  - hou.Geometry.findPointAttrib()

Returns 1 if a specified point attribute exists.

USAGE
  haspointattrib(<surface_node>, <attribute>)

}

{
hasprim

REPLACED BY
  - hou.Geometry.prims()
  - hou.PrimGroup

Returns 1 if a specified primitive is in a specified group.

USAGE
  hasprim(<group_name>, <surface_node>, <prim_num>)

The function will return 0 if the group is a point group.

EXAMPLES

  > hasprim("ears", "/obj/geo1/facet1", 3)
    Returns 1 if the group "ears" contains primitive number 3, otherwise
    returns 0.

RELATED

  * haspoint

  * pointlist

  * primlist

}

{
hasprimattrib

REPLACED BY
  - hou.Geometry.findPrimAttrib()

Returns 1 if a specified primitive attribute exists.

USAGE
  hasprimattrib(<surface_node>, <attribute>)

}

{
hasvertexattrib

REPLACED BY
  - hou.Geometry.findVertexAttrib()

Returns 1 if a specified vertex attribute exists.

USAGE
  hasvertexattrib(<surface_node>, <attribute>)

}

{
hextoint
Converts a hexadecimal argument string into an integer.

USAGE
  hextoint(<value>)

EXAMPLES

  > hextoint("A1")
    Returns 161.

RELATED

  * inttohex

}

{
hsv
Converts RGB values to HSV components.

USAGE
  hsv(<red>, <green>, <blue>, <component>)

The <component> should be one of "h", "s" or "v".

EXAMPLES

  > hsv(.3, .6, .4, "h")

}

{
ic

REPLACED BY
  - hou.ChopNode

Evaluates a CHOP's input channel at a specific index.

USAGE
  ic(<input_index>, <channel_index>, <index>)

EXAMPLES

  > ic(0, 2, 10)

RELATED

  * ics

  * ic

  * ice

  * icr

  * icn

  * icmin

  * icmax

  * icl

  * oc

}

{
ice

REPLACED BY
  - hou.ChopNode

Returns the end index of a CHOP's input.

USAGE
  ice(<input_index>)

EXAMPLES

  > ice(0)

RELATED

  * ics

  * ic

  * ice

  * icr

  * icn

  * icmin

  * icmax

  * icl

  * oc

}

{
icl

REPLACED BY
  - hou.ChopNode
  - hou.Node.inputs()
  - hou.Node.outputConnectors()

Returns the length of a CHOP's input, in samples.

USAGE
  icl(<input_index>)

EXAMPLES

  > icl(0)

RELATED

  * ics

  * ic

  * ice

  * icr

  * icn

  * icmin

  * icmax

  * icl

  * oc

}

{
icmax

REPLACED BY
  - hou.ChopNode

Evaluates a CHOP's input channel's maximum value.

USAGE
  icmax(<input_index>, <channel_index>)

EXAMPLES

  > icmax(0, 2)

RELATED

  * ics

  * ic

  * ice

  * icr

  * icn

  * icmin

  * icmax

  * icl

  * oc

}

{
icmin

REPLACED BY
  - hou.ChopNode

Evaluates a CHOP's input channel's minimum value.

USAGE
  icmin(<input_index>, <channel_index>)

EXAMPLES

  > icmin(0, 2)

RELATED

  * ics

  * ic

  * ice

  * icr

  * icn

  * icmin

  * icmax

  * icl

  * oc

}

{
icn

REPLACED BY
  - hou.ChopNode
  - hou.Node.inputs()
  - hou.Node.outputConnectors()

Returns the number of channels in a CHOP's input.

USAGE
  icn(<input_index>)

EXAMPLES

  > icn(0)

RELATED

  * ics

  * ic

  * ice

  * icr

  * icn

  * icmin

  * icmax

  * icl

  * oc

}

{
icr

REPLACED BY
  - hou.ChopNode
  - hou.Node.inputs()
  - hou.Node.outputConnectors()

Returns the sample rate of a CHOP's input.

USAGE
  icr(<input_index>)

EXAMPLES

  > icr(0)

RELATED

  * ics

  * ic

  * ice

  * icr

  * icn

  * icmin

  * icmax

  * icl

  * oc

}

{
ics

REPLACED BY
  - hou.ChopNode
  - hou.Node.inputs()
  - hou.Node.outputConnectors()

Returns the start index of a CHOP's input.

USAGE
  ics(<input_index>)

EXAMPLES

  > ics(0)

RELATED

  * ics

  * ic

  * ice

  * icr

  * icn

  * icmin

  * icmax

  * icl

  * oc

}

{
identity

REPLACED BY
  - hou.Matrix4.setToIdentity()
  - hou.hmath.identityTransform()

Creates an identity matrix.

USAGE
  identity(<size>)

The resulting identity matrix will have <size> rows and <size> columns.

}

{
if
Returns the value of the second or third argument depending on the truth
of the first argument.

USAGE
  if(<expression>, <true_value>, <false_value>)


NOTE
    This is a function, which means all parameters to the function are
    evaluated. So something like if($F > 1, system('echo 1'),
    system('echo 2')) will result in both system calls being run
    regardless of the result of the expression.

EXAMPLES

  > if ($F<12, $F, 75)
    When the current frame number ($F) is less than 12, returns the
    current frame number, otherwise returns 75.

RELATED

  * ifs

}

{
ifs
Returns the string value of the second or third argument depending on
the truth of the first argument.

USAGE
  ifs(<expression>, <true_value>, <false_value>)


NOTE
    This is a function, which means all parameters to the function are
    evaluated. So something like ifs($F > 1, system('echo one'),
    system('echo two')) will result in both system calls being run
    regardless of the result of the expression.

EXAMPLES

  > ifs ($F<12, padzero(4, $F), "0075")
    When the current frame number ($F) is less than 12, returns a string
    containing the current frame number padded to four digits, otherwise
    returns 0075.

RELATED

  * if

}

Expression functions

Expression functions let you compute the value of parameters.

See the network and parameters chapter for more information on HScript
expressions. You can also use Python in parameters instead of HScript
expressions.

FUNCTIONS


{
index
Finds the first occurrence of a pattern in a string.

USAGE
  index(<source>, <pattern>)

Returns the number of characters before <pattern> occurs in <source>.
Returns -1 if the pattern is not found.

EXAMPLES

  > echo `index("Testing index", "sting")`
    Prints 2

  > echo `index("Testing index", "i")`

    Prints 4

RELATED

  * rindex

}

{
instancepoint
Returns the point number currently being instanced onto.

USAGE
  instancepoint()

This function takes no arguments. You can use this function in parameter
expressions on objects being instanced (see point instancing). It
returns the point number the object is being instanced onto. You can use
this to vary _object-level_ parameters (such as transforms or material
overrides) between instances.

You can *not* use this function at the surface level, because instancing
only works at the object level.

}

{
int
Converts a number to an integer by truncating any fractional part.

USAGE
  int(<number>)

EXAMPLES

  > int(2.501)=2
  > int(-2.501)=-2
  > int(0.2)=0
  > int(-.2)=0

RELATED

  * trunc

  * floor

  * ceil

  * round

}

{
inttohex
Converts a number into a hexadecimal string.

USAGE
  inttohex(<value>)

EXAMPLES

  > inttohex(123)
    Returns "0000007B"

RELATED

  * hextoint

}

{
invert

REPLACED BY
  - hou.Matrix4.inverted()

Inverts a matrix.

USAGE
  invert(<mat>)

This is only valid if the matrix is a 4x4 or 3x3 matrix. If the matrix
is larger than 4x4, the matrix will be converted to a 4x4 matrix before
it is inverted. If the matrix is smaller than 3x3, the matrix will be
enlarged to a 3x3 matrix before it is inverted. The results of enlarging
the matrix to a 3x3 are not guaranteed.

}

{
iprquery

REPLACED BY
  - hou.IPRViewer.isPreviewOn()
  - hou.IPRViewer.setPreview()
  - hou.IPRViewer.imageResolution()
  - hou.IPRViewer.cropRegion()
  - hou.IPRViewer.planes()
  - hou.IPRViewer.displayedPlane()
  - hou.IPRViewer.pixel()
  - hou.IPRViewer.prim()

Queries numeric (floating point) data from an interactive render pane.

USAGE
  iprquery(<query>, <pane>, <x>, <y>)

Use iprquerys to query textual (string) information.

The <query> string argument specifies what type of information to
retrieve (see below). The <pane> argument specifies the name of the pane
you want to retrieve information for.

The <x> and <y> arguments are used by some query types to specify
additional query parameters. For queries that do not require extra
parameters, they are ignored.

The <query> string can be one of the following values:


cropx0, cropx1, cropy0, cropy1
    Returns the left, right, top, or bottom values of the currently
    selected crop region.

exist.<plane_name>
    Returns the index of the given plane if it exists in the rendered
    image, or -1 if it does not.

ipr
    Returns 1 if the IPR button is on, or 0 if it is off.

lock
    Returns 1 if the lock button is on (prevents automatic re-
    rendering), or 0 if it is off.

nplanes
    Returns the number of deep raster planes in the current image.

object.ptinstance
    Point number of the instance object (see "Object queries" below)
    that contributed the pixel at <x>,<y>. The <x> and <y> variables are
    coordinates in the rendered image.

object.primitive
    Primitive number of the geometry object (see "Object queries" below)
    that contributed the pixel at <x>,<y>. The <x> and <y> variables are
    coordinates in the rendered image.

pindex.<name>
    Returns the index of the deep raster plane named <name>. If there is
    no plane by that name, returns -1.

plane.vsize
    Returns the vector size of the plane at the index specified by the
    <x> argument to this function. For example, to get the vector size
    of the third deep raster plane:

  > iprquery("plane.vsize", $PANE, 2, 0)

    (The <y> argument, here set to 0, is ignored.)

plane.<name>[.r|g|b|a]
    Returns the value of the pixel component at <x>,<y> of the plane
    named <name>. For example:

  > iprquery("plane.C.g", $PANE, $IX, $IY)

    If you don't specify a component name (.r, .g, .b, or .a), returns
    the value of the first component.

    You can also use .x, .y, .z, and .w as alternate names for .r, .g,
    .b, and .a. For example, plane.N.y is equivalent to plane.N.g.

xres, yres
    horizontal or vertical resolution of the image in the interactive
    render viewer.

OBJECT QUERIES

    The queries beginning with object. give you information about the
    Houdini objects that produced the IPR image. These queries use two
    deep raster planes mantra creates automatically when rendering.
    These floating-point planes are named Op-Id and Prim-Id. Houdini
    maintains a table mapping the data Op-Id plane to information about
    the instance and geometry in the render. _The numbers in the Op-Id
    plane are meaningless otherwise_.

RELATED

  * iprquerys

}

{
iprquerys

REPLACED BY
  - hou.IPRViewer.ropNode()
  - hou.IPRViewer.planes()
  - hou.IPRViewer.displayedPlane()
  - hou.IPRViewer.objectNode()
  - hou.IPRViewer.materialNode()

Queries textual (string) data from an interactive render pane.

USAGE
  iprquerys(<query>, <pane>, <x>, <y>)

Use iprquery to query numeric (floating point) information.

The <query> string argument specifies what type of information to
retrieve (see below). The <pane> argument specifies the name of the pane
you want to retrieve information for.

The <x> and <y> arguments are used by some query types to specify
additional query parameters. For queries that do not require extra
parameters, they are ignored.

The <query> string can be one of the following values:


object.instance
    Full path of the instanced object that contributed the pixel at <x>,
    <y>. If the object was not instanced, this will be the same as
    object.geometry. See "Object queries" below. The <x> and <y>
    arguments are coordinates in the rendered image.

object.geometry
    Full path of the geometry object that contributed the pixel at <x>,
    <y>. See "Object queries" below. The <x> and <y> arguments are
    coordinates in the rendered image.

object.surface
    Full path of the surface shader that contributed the pixel at <x>,
    <y>. See "Object queries" below. The <x> and <y> arguments are
    coordinates in the rendered image.

object.displace
    Full path of the displacement shader that affected the pixel at <x>,
    <y>. See "Object queries" below. The <x> and <y> arguments are
    coordinates in the rendered image.

plane.name
    Returns the name of the plane at the index specified by the <x>
    argument to this function. For example, to get the name of the third
    deep raster plane:

  > iprquerys("plane.name", $PANE, 2, 0)

    (The <y> argument, here set to 0, is ignored.)

rop
    Returns the full path of the output driver node displayed in the
    interactive render pane.

OBJECT QUERIES

    The queries beginning with object. give you information about the
    Houdini objects that produced the IPR image. These queries use two
    deep raster planes mantra creates automatically when rendering.
    These floating-point planes are named Op_Id and Prim_Id. Houdini
    maintains a table mapping the data Op_Id plane to information about
    the instance and geometry in the render. The numbers in the Op_Id
    plane are meaningless otherwise.

RELATED

  * iprquery

}

{
isclosed

REPLACED BY
  - hou.Face.isClosed()

Returns 1 if a primitive is closed.

USAGE
  isclosed(<surface_node>, <prim_num>)

This is the same as iswrapu, and works on polygonal, NURBS, and Bezier
curves and surfaces.

RELATED

  * iswrapu

  * iswrapv

}

{
iscollided
Returns 1 if a specified point has collided with something.

USAGE
  iscollided(<surface_node>, <pointnumber>)

EXAMPLES

  > iscollided("../particle1", $PT)

}

{
ishvariable
Returns 1 if a specified Houdini environment variable exists.

USAGE
  ishvariable(<variable_name>)

Checks only houdini variables to see if variable_name exists. System
variables are not checked.

RELATED

  * isvariable

}

{
isspline
Returns 1 if a specified primitive is a NURBs or Bezier curve or
surface.

USAGE
  isspline(<surface_node>, <prim_num>)

}

{
isstuck
Returns 1 if a specified point is a stuck particle.

USAGE
  isstuck(<surface_node>, <pointnumber>)

Warning: this function can be slow.

EXAMPLES

  > isstuck("../particle1", $PT)

}

{
isvariable
Returns 1 if a specified Houdini or system environment variable exists.

USAGE
  isvariable(<variable_name>)

RELATED

  * ishvariable

}

{
iswrapu

REPLACED BY
  - hou.Surface.isClosedInU()

Returns 1 if a specified primitive is wrapped in U.

USAGE
  iswrapu(<surface_node>, <prim_num>)

Returns 1 if the primitive is wrapped in the u direction. For curves,
this is the same as isclosed.

RELATED

  * isclosed

  * iswrapv

}

{
iswrapv

REPLACED BY
  - hou.Surface.isClosedInV()

Returns 1 if a specified primitive is wrapped in V.

USAGE
  iswrapv(<surface_node>, <prim_num>)

Curves, circles, etc, are always considered to be unwrapped in V since
they are only exist in U.

RELATED

  * isclosed

  * iswrapu

}

{
length

REPLACED BY
  - hou.Vector3.length()

Returns the length of a vector.

USAGE
  length(<x>, <y>, <z>)

A.K.A sqrt(x*x + y*y + z*z).

}

{
linear
Channel segment function: linear interpolation.

USAGE
  linear()

RELATED

  * constant

}

{
listbyval
Returns a list of elements with a given value for an integer attribute.

USAGE
  listbyval(<surface_node>, <class>, <attribute>, <id>)

The <class> can be one of D_VERTEX,D_POINT, D_PRIMITIVE, or D_DETAIL for
the corresponding attribute class.

EXAMPLES

  > listbyval("/obj/geo1/facet1", D_PRIMITIVE, "piece", 1)
    Returns a list of primitives with a value of 1 for the piece
    attribute in the facet1 surface node in geo1.

}

{
listbyvals
Returns a list of elements with a given value for a string attribute.

USAGE
  listbyvals(<surface_node>, <class>, <attribute>, <id>)

The <class> can be one of D_VERTEX, D_POINT, D_PRIMITIVE, or D_DETAIL
for the corresponding attribute class.

EXAMPLES

  > listbyvals("/obj/geo1/facet1", D_PRIMITIVE, "name", "piece1")
    Returns a list of primitives with a value of piece1 for the name
    attribute in the facet1 surface node in geo1.

}

{
lock

REPLACED BY
  - hou.BaseKeyframe

Returns a value that cannot be changed.

USAGE
  lock(<float>)

This function simply returns the value of its argument. However, it is
special in that if an expression is enclosed in a lock function, then
its values cannot be changed, until the lock expression is removed.

}

{
log
Returns the natural logarithm of the argument.

USAGE
  log(<number>)

EXAMPLES

  > log (2.718281828)= 1

}

{
log10
Returns the base 10 logarithm of the argument.

USAGE
  log10(<number>)

EXAMPLES

  > log10(10) = 1
  > log10(100) = 2

}

{
lopinputprim
Returns the path of the USD primitive last modified by an input to a LOP
node.

USAGE
  lopinputprim(<lop_path>, <input_index>)


This function is a shortcut, equivalent to the following expression
  > loplastmodifiedprim(opinput(<<lop_path>>, <<input_index>>))
See loplastmodifiedprim for more information about the last modified
primitive value.

RELATED

  * loplastmodifiedprim

}

{
lopinputprims
Returns the paths of the USD primitives last modified by an input to a
LOP node.

USAGE
  lopinputprims(<lop_path>, <input_index>)


This function is a shortcut, equivalent to the following expression
  > loplastmodifiedprims(opinput(<<lop_path>>, <<input_index>>))
See loplastmodifiedprims for more information about the last modified
primitives value.

RELATED

  * loplastinputprim()

  * loplastmodifiedprims

}

{
loplastmodifiedprim
Returns the path of the USD primitive last modified by a LOP node.

USAGE
  loplastmodifiedprim(<lop_path>)

LOP nodes may set the path to the USD primitive most recently modified
by the node. For example a LOP node that creates a USD primitive would
set this value to the newly created USD primitive. A LOP node which
edits a USD primitive may set it to the path of the modified primitive.
This expression function returns this stored USD primitive path for the
node specified by the <lop_path> parameter.

Using this expression function it is easy to create and edit scene graph
hierarchies without using complex channel referencing expressions.

RELATED

  * lopinputprim

}

{
loplastmodifiedprims
Returns the paths of the USD primitives last modified by a LOP node.

USAGE
  loplastmodifiedprims(<lop_path>)

LOP nodes may set the paths to the USD primitives most recently modified
by the node. For example a LOP node that creates a USD primitive would
set this value to the newly created USD primitive. A LOP node which
edits several USD primitives may set it to the paths of all the modified
primitives. This expression function returns these stored USD primitive
paths for the node specified by the <lop_path> parameter.

If more than one primitive was modified by the LOP node, the paths are
returned in a single string separated by spaces.

Using this expression function it is easy to create and edit scene graph
hierarchies without using complex channel referencing expressions.

RELATED

  * lopinputprims

  * loplastmodifiedprim

}

{
match
Channel segment function: matches the incoming and outgoing slopes.

USAGE
  match()

The curve will move smoothly from the in coming value to the out going
value.

RELATED

  * vmatch

  * matchin

  * matchout

}

{
matchin

REPLACED BY
  - hou.matchin()

Channel segment function: matches the incoming slope.

USAGE
  matchin()

RELATED

  * vmatchin

  * match

  * matchout

}

{
matchout

REPLACED BY
  - hou.matchout()

Channel segment function: matches the outgoing slope.

USAGE
  matchout()

RELATED

  * vmatchout

  * match

  * matchin

}

{
matrix

REPLACED BY
  - hou.Matrix2.__init__()
  - hou.Matrix3.__init__()
  - hou.Matrix4.__init__()

Converts a string specification into a matrix.

USAGE
  matrix(<pattern>)

The string should start with a square bracket, followed by a series of
rows (specified as vector patterns - see the vector function), followed
by a trailing square bracket.

To access a row out of the matrix, use the square bracket operator.

EXAMPLES

  > matrix m = matrix("[[1,2,3][2,3,5][-3,2,-3]]");
  > vector v = m[0];    # v is [1,2,3]
  > float  f = m[0][2]; # f is 3

}

{
matrixtoquat
Converts a rotation matrix to a quaternion.

USAGE
  matrixtoquat(<m>)

Computes a quaternion which represents the rotation specified by the
matrix.

RELATED

  * quattomatrix

}

{
max
Returns the larger of two values.

USAGE
  max(<value1>, <value2>)

EXAMPLES

  > max (5,3) = 5

}

{
mcols
Returns the number of columns in a matrix.

USAGE
  mcols(<mat>)

}

{
metaweight
Returns the weight of a metaball at a specific location.

USAGE
  metaweight(<surface_node>, <x>, <y>, <z>)

EXAMPLES

  > metaweight("/obj/geo1/metaball", $TX, $TX, $TZ)

}

{
min
Returns the smaller of two values.

USAGE
  min(<value1>, <value2>)

EXAMPLES

  > min (5,3) = 3

}

{
mindist
Finds the smallest distance between a point and a primitive.

USAGE
  `mindist(<surface_node>, <point_num>, <surface_node>, <prim_num>,
  <return_type>)`

This expression is an alias for pointdist.

RELATED

  * pointdist

  * primdist

  * distance

  * uvdist

}

{
mlookat

REPLACED BY
  - hou.ObjNode.buildLookatRotation()

Computes the transformation matrix of a lookat from one vector to
another.

USAGE
  mlookat(<v1>, <v2>)

Computes a transform matrix specifying a lookat from vector <v1> to the
vector <v2>.

The vectors are converted to 3 vectors for this computation. The
resulting matrix will be a 3x3 matrix.

EXAMPLES

  > explodematrix(mlookat(vtorigin("","/obj/from"),vtorigin("","/obj/to")),"SRT","XYZ","RX")
    Computes the lookat matrix and returns the rotation value for RX.

RELATED

  * mlookatup

}

{
mlookatup
Computes the transformation matrix of a lookat from one vector to
another, with an up vector.

USAGE
  mlookatup(<v1>, <v2>, <upv>)

Computes a transform matrix specifying a lookat from vector <v1> to the
vector <v2>, taking up vector <upv> into consideration.

The vectors are converted to 3 vectors for this computation. The
resulting matrix will be a 3x3 matrix.

EXAMPLES

  > explodematrix(mlookatup(vtorigin("","/obj/from"),vtorigin("","/obj/to"),vtorigin("","/obj/up")),"SRT","XYZ","RX")
    Computes the lookat matrix and returns the rotation value for RX.

RELATED

  * mlookat

}

{
mobjlookat

REPLACED BY
  - hou.ObjNode.buildLookatRotation()

Computes the transformation matrix of a lookat from one object to
another.

USAGE
  mobjlookat(<base_node>, <target_node>, <upv>)

EXAMPLES

  > mobjlookat("/obj/null1", "/obj/null2", vector3(0,1,0))
    Returns the transformation matrix to get null1 to look at null2

}

{
modblend
Blends the two modular values.

USAGE
  modblend(<val1>, <val2>, <length>, <weight>)

This function can be used to correctly blend two angles or other cyclic
values.

EXAMPLES

  > modblend(355, 5, 360, 0.5)
    Returns 0. Simple linearly blending of the two values would result
    in an incorrect value of 180.

}

{
morient
Computes the transformation matrix to orient along specific Z and Y
axes.

USAGE
  morient(<zaxis>, <yaxis>)

Computes the transform matrix to rotate the x,y,z axes such that the
specified zaxis is the new zaxis and yaxis the new yaxis. The resulting
matrix is a 3x3 matrix.

}

{
mousepane
Returns the full name of the pane currently under the mouse pointer.

USAGE
  mousepane()

If this function is executed when the mouse pointer is not over any pane
(such as when it is outside the Houdini window) an empty string is
returned. An empty string is also returned when this function is
executed within non-graphical Houdini applications such as hscript.

RELATED

  * mousepath

}

{
mousepath

REPLACED BY
  - hou.PathBasedPaneTab

Returns the node path of the pane currently under the mouse pointer.

USAGE
  mousepath()

If this function is executed when the mouse pointer is not over any pane
(such as when it is outside the Houdini window) an empty string is
returned. An empty string is also returned when this function is
executed within non-graphical Houdini applications such as hscript.

RELATED

  * mousepane

}

{
mrows
Returns the number of rows in a matrix.

USAGE
  mrows(<mat>)

}

{
mzero

REPLACED BY
  - hou.Matrix4.setToZero()

Returns a matrix with all values set to 0.

USAGE
  mzero(<mat>)

}

{
nearpoint
Finds the point in a geometry nearest to specific 3D coordinates.

USAGE
  nearpoint(<surface_node>, <x>, <y>, <z>)

Finds the nearest point in the surface node's geometry to the given
point (<x>, <y>, <z>). The return value is the point number of the
nearest point.

EXAMPLES

  > nearpoint("/obj/geo1/grid1", 1, 2, 3)
    Returns the point in the grid closest to (1, 2, 3).

RELATED

  * xyzdist

  * primdist

  * pointdist

}

{
noise

REPLACED BY
  - hou.hmath.noise1d()

Generates 3D noise.

USAGE
  noise(<X>, <Y>, <Z>)

The noise is calculated on a unit-spaced lattice and then internal
points are interpolated from lattice points. This means the noise will
be independent between points one unit distance apart. You can scale the
inputs to achieve different frequencies.

This function can be used to apply noise to geometry. For example to
make a bumpy grid you could append a point surface node and use the
following in the pos Z field:

noise($TX, $TY, $TZ)

RELATED

  * snoise

  * turb

  * sturb

}

{
normal

REPLACED BY
  - hou.Surface.normalAt()

Returns the components of the surface normal specific UV coordinates.

USAGE
  normal(<surface_node>, <prim_num>, <u>, <v>, <index>)

<u> and <v> are unit values, defined in the [0,1] interval. If the
primitive is a mesh, u and v are defined in terms its number of rows and
columns.

<index> specifies which component to return, where 0 means X, 1 means Y,
and 2 means Z.

RELATED

  * unituv

  * primuv

  * primduv

  * curvature

}

{
normalize

REPLACED BY
  - hou.Vector3.normalized()

Normalizes a vector.

USAGE
  normalize(<v>)

}

{
npoints
Returns the number of points in a geometry.

USAGE
  npoints(<surface_node>)

Returns -1 if the surface node cannot be cooked.

}

{
npointsgroup
Returns the number of points in the specified group.

USAGE
  npointsgroup(<surface_node>, <group_name>)

Returns -1 if the surface node cannot be cooked or 0 if the group does
not exist.

}

{
nprims
Returns the number of primitives in a surface node.

USAGE
  nprims(<name>)

Returns -1 if the surface node cannot be cooked.

}

{
nprimsgroup
Returns the number of primitives in the specified group.

USAGE
  nprimsgroup(<surface_node>, <group_name>)

Returns -1 if the surface node cannot be cooked or 0 if the group does
not exist.

}

{
nuniquevals
Returns the number of unique values for an integer or string attribute
in a surface node.

USAGE
  nuniquevals(<surface_node>, <class>, <attribute>)

The <class> can be one of D_VERTEX, D_POINT, D_PRIMITIVE, or D_DETAIL
for the corresponding attribute class.

EXAMPLES

  > nuniquevals("/obj/geo1/facet1", D_PRIMITIVE, "name")
    Returns the number of unique values for the primitive attribute name
    in the facet1 surface node in geo1.

}

{
objkinoverride
Returns the current global kinematic override setting for bone objects.

USAGE
  objkinoverride()

This is equivalent to running the objkinoverride command without any
arguments.

Return values are: none (no overrides, rest (bones cook using the rest
transform), or capture (bones cook using the capture pose transform).

EXAMPLES

  > objkinoverride()

RELATED

  * objkinoverride

}

{
objlightmask
Returns a list of lights matching an object's light mask.

USAGE
  objlightmask(<geometry>, <options>)

This is a slightly more general form of the oplightmask function.

Returns a string containing a space separated list of path names.

The options allow some control over how the light names are generated.
Currently, options include:


f
    Generate full path names for the lights. If this option is excluded,
    the path names will be generated relative to /obj

a
    Ignore ambient lights.

A
    Only include ambient lights.

EXAMPLES

  > objlightmask("/obj/geo1", "fa")
    Returns all the lights in /obj/geo1's light-mask. Any ambient lights
    will be excluded from the expanded string, and the paths generated
    will be the full path name of the light. The string might look
    something like "/obj/light1 /obj/light2 /obj/subnet1/light1".

RELATED

  * oplightmask

}

{
objlookat
Computes the rotation vector of a lookat from one object to another.

USAGE
  objlookat(<base_node>, <target_node>, <upv>)

EXAMPLES

  > objlookat("/obj/null1","/obj/null2",vector3(0,1,0))[0]
    Returns the rotation parameter for Rx to get null1 to look at null2

}

{
objpretransform

REPLACED BY
  - hou.ObjNode.preTransform()

Returns an object's pre-transform matrix.

USAGE
  objpretransform(<object_name>)

EXAMPLES

  > objpretransform("/obj/bone1")
    Returns the pretransform matrix for /obj/bone1.

}

{
oc

REPLACED BY
  - hou.ChopNode

Returns the value of a CHOP's output at a specific sample index.

USAGE
  oc(<output_channel_index>, <index>)

EXAMPLES

  > oc(0, 10)

RELATED

  * ics

  * ic

  * ice

  * icr

  * icn

  * icmin

  * icmax

  * icl

  * oc

}

{
oldrand
Returns a pseudo-random number between 0 and 1.

USAGE
  oldrand(<value>)

Using the same <value> will give the same result each time. A different
number is returned if fractional values are different.


NOTE
    It is a good idea to use non-integer values as the argument to
    oldrand(). This function is similar to rand() but uses a different
    algorithm for generating the random numbers.

EXAMPLES

  > oldrand(12.1) gives a different result than oldrand(12.2)

RELATED

  * rand

}

{
opblist

REPLACED BY
  - hou.NodeBundle.nodes()

Returns the full paths of all operators in a bundle.

USAGE
  opblist(<bundle_name>)

Returns a string containing a space separated list of paths.

}

{
opcreator
Returns the creator of this node.

USAGE
  opcreator(<name>)

EXAMPLES

  > opcreator("/obj/geo1/line1")
    Returns /obj/geo1, indicating that object geo1 is the creator
    network for line1.

RELATED

  * optypeinfo

}

{
opdigits

REPLACED BY
  - hou.NetworkMovableItem.digitsInName()

Returns the numeric suffix of a node name.

USAGE
  opdigits(<name>)

This function will return the numeric value of the last set of
consecutive digits in a node's name.

EXAMPLES

  > opdigits("/obj/geo1") = 1
  > opdigits(".") = 1

}

{
opexist

REPLACED BY
  - hou.Node.node()
  - hou.NodeBundle.containsNode()
  - hou.nodeBySessionId()
  - hou.node()
  - hou.nodes()

Returns 1 if the specified node, group, or bundle exists.

USAGE
  opexist(<op_name>)

EXAMPLES

  > echo `opexist("../box1")`
  > echo `opexist("/obj/@mygroup")`
  > echo `opexist("@mybundle")`

}

{
opflag

REPLACED BY
  - hou.ChopNode
  - hou.CopNode.isDisplayFlagSet()
  - hou.CopNode.isRenderFlagSet()
  - hou.CopNode.isTemplateFlagSet()
  - hou.CopNode.isCompressFlagSet()
  - hou.CopNode.isBypassed()
  - hou.CopNode
  - hou.DopNode.isTemplateFlagSet()
  - hou.DopNode.isBypassed()
  - hou.NetworkMovableItem.isSelected()
  - hou.NetworkMovableItem.isPicked()
  - hou.Node.isCurrent()
  - hou.Node.isDisplayDescriptiveNameFlagSet()
  - hou.Node.outputForViewFlag()
  - hou.Node.isHidden()
  - hou.ObjNode.isDisplayFlagSet()
  - hou.ObjNode.isSelectableInViewport()
  - hou.ObjNode.isShowingOrigin()
  - hou.ObjNode.isUsingXray()
  - hou.PopNode
  - hou.RopNode
  - hou.SopNode.isBypassed()
  - hou.SopNode.isDisplayFlagSet()
  - hou.SopNode.isRenderFlagSet()
  - hou.SopNode.isHighlightFlagSet()
  - hou.SopNode.isTemplateFlagSet()
  - hou.SopNode.isSelectableTemplateFlagSet()
  - hou.SopNode.isHardLocked()
  - hou.SopNode.isSoftLocked()
  - hou.SopNode.isUnloadFlagSet()
  - hou.VopNode.isDebugFlagSet()
  - hou.VopNode.isDetailLowFlagSet()
  - hou.VopNode.isDetailMediumFlagSet()
  - hou.VopNode.isDetailHighFlagSet()
  - hou.VopNode.isBypassed()
  - hou.VopNode.isCompressFlagSet()
  - hou.VopNode.isMaterialFlagSet()

Returns a list nodes with a particular flag set.

USAGE
  opflag(<network>, <flag>)

The <flag> argument follows the same convention as the opset command.
Examples are:


"d"
    Display Flag

"r"
    Render Flag

"t"
    Template

"b"
    Bypass

"l"
    Lock.

"e"
    Expose

"h"
    Highlight

"f"
    Footprint

"s"
    This should be the save data in a motion file flag. However, for
    backwards compatibility it is aliased to the pick flag. Use of "s"
    should be replaced with "p"

"u"
    Unload data after cook (surface nodes and CHOPs only).

"c"
    This should be the compress icon flag. However, for backwards
    compatibility it is aliased to the "C" flag. Use of "c" should be
    replaced by "C".

"C"
    Current

"p"
    Picked

"P"
    Display descriptive parm.

"O"
    Output For View.

The following flags are only available for objects:


"S"
    Selectable in viewport

"x"
    Object pivot axes

"y"
    Xray

The following flags are only available for CHOPs.


"a"
    Audio

"o"
    Export

EXAMPLES

  > hscript -> echo `opflag("/obj", "d")`
    Lists all displayed objects

  > hscript -> echo `opflag("/obj/geo1", "l")`

    Lists all locked surface nodes in object geo1.

RELATED

  * opselect

  * opselectrecurse

}

{
opfullpath

REPLACED BY
  - hou.NetworkMovableItem.path()
  - hou.pwd()

Returns the full path of a node.

USAGE
  opfullpath(<relpath>)

RELATED

  * opfullpathfrom

  * oprelativepath

  * opname

  * opsubpath

}

{
opfullpathfrom

REPLACED BY
  - hou.Node.node()

Returns the path of a node relative to another node.

USAGE
  opfullpathfrom(<node>, <basenode>)

This function will return the full path to <node>, relative to
<basenode>. If <basenode> is a relative path it is relative to the
current nodes.

RELATED

  * oprelativepath

  * opfullpath

  * opname

  * opsubpath

}

{
opid

REPLACED BY
  - hou.NetworkMovableItem.sessionId()

Returns the unique ID of a node.

USAGE
  opid(<name>)

The value of the ID is unique to that operator at any given moment,
however it changes each time Houdini is reloaded.

EXAMPLES

  > opid("/obj/model")
    Returns a unique ID of the model object.

}

{
opinput

REPLACED BY
  - hou.Node.inputConnectors()

Returns the name of the node connected to a given input.

USAGE
  opinput(<name>, <index>)

<index> is the 0-based number of the input. For example, to get the name
of the node connected to the first input, use opinput(".", 0), and for
the second input, use opinput(".", 1).

EXAMPLES

  > point("../" + opinput(".", 0), $PT, "P", 0)

RELATED

  * opinputpath

  * opninputs

  * opoutput

  * opoutputpath

  * opnoutputs

}

{
opinputpath

REPLACED BY
  - hou.NetworkMovableItem.path()

Returns the full path of the node connected to a given input.

USAGE
  opinputpath(<name>, <index>)

<index> is the 0-based number of the input. For example, to get the path
of the node connected to the first input, use opinputpath(".", 0), and
for the second input, use opinputpath(".", 1).

EXAMPLES

  > point(opinputpath(".", 0), $PT, "P", 0)

RELATED

  * opinput

  * opninputs

  * opoutput

  * opoutputpath

  * opnoutputs

}

{
opisloading

REPLACED BY
  - hou.hipFile.isLoadingHipFile()

Returns 1 if Houdini is currently loading a scene file.

USAGE
  opisloading()

}

{
opisquitting

REPLACED BY
  - hou.hipFile.isShuttingDown()

Returns 1 if Houdini is currently shutting down.

USAGE
  opisquitting()

This information is particularly useful in node deletion scripts to
determine if the node is being deleted because Houdini is quitting
rather than because the user chose to delete it.

}

{
oplightmask
Returns a list of lights matching an object's light mask.

USAGE
  oplightmask(<geometry>)

Returns a string containing a space separated list of path names.

This function is equivalent to objlightmask(geometry, "f").

EXAMPLES

  > oplightmask("/obj/geo1")
    Might return the string "/obj/ambient1 /obj/light1
    /obj/subnet1/light1".

RELATED

  * objlightmask

}

{
oplistsort

REPLACED BY
  - hou.sortedNodePaths()
  - hou.sortedNodes()

Sorts a list of node paths based on node input/outputs order.

USAGE
  oplistsort("path")

> oplistsort( "/obj/null1 /obj/null2 /obj/null3")

RELATED

  * chsoplist

}

{
opname

REPLACED BY
  - hou.NetworkMovableItem.name()
  - hou.NetworkMovableItem.setName()

Returns the name of a node given its path.

USAGE
  opname(<name>)

This is useful to find out the name of the network containing the node,
e.g. opname("..") will return the name of the network containing the
current node.

RELATED

  * opfullpath

  * opsubpath

  * oprelativepath

}

{
opnchildren

REPLACED BY
  - hou.Node.children()

Returns the number of nodes inside a container node.

USAGE
  opnchildren(<name>)

This will return the number of nodes in a subnetwork or the number of
surface nodes in an Geometry container object.

The count is non-recursive: it only counts the direct contents of the
node, not of the sub-nodes as well.

}

{
opninputs

REPLACED BY
  - hou.Node.inputs()
  - hou.Node.outputConnectors()

Returns the maximum number of connected inputs.

USAGE
  opninputs(<name>)

Returns the number of the highest connected input. This is _not_ the
number of connected inputs. If a node has four inputs and the fourth
input is connected, opninputs will return 4. If the first and third
inputs are connected, opninputs will return 3.

RELATED

  * opinput

  * opoutput

  * opnoutputs

}

{
opnoutputs

REPLACED BY
  - hou.Node.outputs()

Returns the number of nodes connected to a node's output.

USAGE
  opnoutputs(<name>)

RELATED

  * opinput

  * opoutput

  * opninputs

}

{
opoutput

REPLACED BY
  - hou.Node.outputs()

Returns the name of a node connected a given node's output.

USAGE
  opoutput(<name>, <index>)

Multiple operators may be connected to a node's output and the index
ordering is arbitrary.

RELATED

  * opinput

  * opinputpath

  * opninputs

  * opoutputpath

  * opnoutputs

}

{
opoutputpath

REPLACED BY
  - hou.NetworkMovableItem.path()

Returns the full path of a node connected a given node's output.

USAGE
  opoutputpath(<name>, <index>)

Multiple operators may be connected to a node's output and the index
ordering is arbitrary.

RELATED

  * opinput

  * opinputpath

  * opninputs

  * opoutput

  * opnoutputs

}

{
oppinput
Deprecated: replaced by opinput.

USAGE
  oppinput(<name>, <index>)

Use opinput instead.

}

{
oppwd

REPLACED BY
  - hou.pwd()

Returns the path of the current network.

USAGE
  oppwd()

This is a shortcut for execute("oppwf").

}

{
oppwf

REPLACED BY
  - hou.pwd()

Prints the path of the current network.

USAGE
  oppwf()

This is a short form for execute("oppwf").

}

{
oprelativepath

REPLACED BY
  - hou.NetworkMovableItem.relativePathTo()

Returns the relative path from one node to another.

USAGE
  oprelativepath(<srcpath>, <destpath>)

RELATED

  * opfullpathfrom

  * opfullpath

  * opname

  * opsubpath

}

{
opselect

REPLACED BY
  - hou.NetworkMovableItem.setSelected()
  - hou.NetworkMovableItem.setPicked()

Returns a list of the selected nodes.

USAGE
  opselect(<network>)

Returns a string with a space separated list of the selected nodes in
the given network.

EXAMPLES

  > echo `opselect("/obj")`
    Returns "geo1 geo2".

RELATED

  * opselectpath

  * opselectrecurse

  * opselectrecursepath

  * opflag

}

{
opselectpath
Returns a list of the full paths of selected nodes.

USAGE
  opselectpath(<network>)

Returns a string with a space separated list of the full paths of
selected nodes in the given network.

EXAMPLES

  > echo `opselectpath("/obj")`
    Returns "/obj/geo1 /obj/geo2".

RELATED

  * opselect

  * opselectrecurse

  * opselectrecursepath

  * opflag

}

{
opselectrecurse

REPLACED BY
  - hou.selectedNodes()

Returns a recursive list of the selected nodes.

USAGE
  opselectrecurse(<network>, <flag>)

Returns a string with a space separated list of the selected nodes in
the given network, including selected children according to the context.

  * <flag> = 0: Do not keep the context. Every selected node will be
    returned.

  * <flag> = 1: Keep the context. It will return only selected nodes
    belonging to the same context as the "network" argument.

EXAMPLES

  > echo `opselectrecurse("/obj/model",1)`
    Returns "edgecusp1 subnet1 subnet1/sphere2"

  > echo `opselectrecurse("/obj/model",0)`

    Returns "edgecusp1 shopnet1 subnet1 subnet1/sphere2".

RELATED

  * opselect

  * opselectpath

  * opselectrecursepath

  * opflag

}

{
opselectrecursepath
Returns a recursive list of the full paths of selected nodes.

USAGE
  opselectrecursepath(<network>, <flag>)

Returns a string with a space separated list of the full paths of
selected nodes in the given network, including selected children
according to the context.

  * <flag> = 0: Do not keep the context. Every selected node will be
    returned.

  * <flag> = 1: Keep the context. It will return only selected nodes
    belonging to the same context as the "network" argument.

EXAMPLES

  > echo `opselectrecursepath("/obj/model",1)`
    Returns "/obj/model/edgecusp1 /obj/model/subnet1
    /obj/model/subnet1/sphere2"

  > echo `opselectrecursepath("/obj/model",0)`

    Returns "/obj/model/edgecusp1 /obj/model/shopnet1 /obj/model/subnet1
    /obj/model/subnet1/sphere2".

RELATED

  * opselect

  * opselectpath

  * opselectrecurse

  * opflag

}

{
opstreamname
Computes the active stream of a node.

In POPs there is the idea of an active stream. This is the set of
particles a micro solver should work on by virtue of its inputs. The
opstreamname expression computes the ad hoc point group for the nodes
active stream.

If the node has only a single solid input that leads to a generator,
this will evaluate to the streamname parameter of that generator. But,
in the presence of merge nodes, it may produce a list of groups that
form the active stream.

USAGE
  string opstreamname(<nodepath>)

}

{
opsubpath
Returns the full path of a node including any containing subnets.

USAGE
  opsubpath(<node>)

RELATED

  * opfullpath

  * oprelativepath

  * opname

}

{
optransform

REPLACED BY
  - hou.ObjNode.worldTransform()

Returns the transformation matrix of an object at the current time.

USAGE
  optransform(<object_name>)
  This function will return the transformation matrix of object_name.

  If object_name is the empty string (""), then the identity matrix is
  returned.

}

{
optype

REPLACED BY
  - hou.Node.type()
  - hou.nodeType()

Returns the type of a node.

USAGE
  optype(<name>)

EXAMPLES

  > optype("/obj/geo1")
    Returns "geo", indicating that object geo1 is a Geometry container
    object.

RELATED

  * optypeinfo

}

{
optypeinfo

REPLACED BY
  - hou.NetworkMovableItem.name()
  - hou.NodeType.name()
  - hou.NodeType.description()
  - hou.NodeType.category()
  - hou.NodeType.helpUrl()
  - hou.NodeType.defaultHelpUrl()
  - hou.NodeTypeCategory.name()
  - hou.nodeType()

Returns type information about a node.

USAGE
  optypeinfo(<name>, <pattern>)

Unlike optype which just returns a node's type, this allows you to
specify a string of parameters which will cause different things to be
output.

The pattern string may contain the following characters.


N
    The name of the node. For /obj/geo1, this would be geo1.

r
    The type of the node, same as in optype. For /obj/geo1, this would
    be geo.

e
    The type's label. For /obj/geo1, this would be Geometry.

n
    The network type of the operator. For /obj/geo1, this would be OBJ.

s
    The script path of the operator. For /obj/geo1, this would be obj.

i
    The operator's index. This number corresponds to the network type.

T
    The table name of the operator. For /obj/geo1, this would be Object.

t
    The operator type. For /obj/model, this would be geo.

o
    The full operator type name, consisting of the table name and
    operator name, separated by a /, while also taking into account any
    namespace or version operator type name components. For /obj/model,
    this would be Object/geo, or for namespaced HDA it may be
    ns::Object/myhda::1.0.

EXAMPLES

  > optypeinfo("/obj/geo1", "NtT")
  > 
  > "geo1 geo Object"

RELATED

  * optype

}

{
origin

REPLACED BY
  - hou.ObjNode.origin()

Returns components of an object's transforms.

USAGE
  origin(<obj1>, <obj2>, <constant_type>)

This function will return one of TX, TY, TZ, RX, RY, RZ, SX, SY, SZ
value necessary to transform obj1 to obj2, depending on the type
argument ("TX", "TY", "TZ", "RX", "RY", "RZ", "SX", "SY" or "SZ" ).

This can also be thought of as the position of obj2 relative to obj1. It
will compute the position of obj1 relative to obj2 and returns one of
TX, TY, TZ, RX, RY, RZ, SX, SY, SZ based on the type argument.

If the empty string ("") is specified for either obj1 or obj2, then the
identity transform will be used instead. For example, if obj1 is the
empty string, then the world space position of obj2 is returned.

RELATED

  * vorigin

  * vtorigin

  * vrorigin

  * originoffset

}

{
originoffset

REPLACED BY
  - hou.ObjNode.getTransformFromPointToPoint()

Returns components of an object's offset transforms.

USAGE
  `originoffset(<obj1>, <pos1>, <obj2>, <pos2>,
  <constant_type>)`

This function will return one of TX, TY, TZ, RX, RY, RZ value necessary
to transform the point pos1 in the space of object obj1 to point pos2 in
the space of object obj2, depending on the type argument ("TX", "TY",
"TZ", "RX", "RY" or "RZ").

This can also be thought of as the position of pos2 in obj2 relative to
pos1 in obj1.

If the empty string ("") is specified for either obj1 or obj2, then the
identity transform will be used instead. For example, if obj1 is the
empty string, then the world space position of obj2 is returned.

RELATED

  * origin

  * vorigin

  * vtorigin

  * vrorigin

}

{
padzero
Returns a string padding a number to a given length with zeros.

USAGE
  padzero(<size>, <value>)

Returns a string containing <value> preceded by enough zeros to make up
<size> digits.

EXAMPLES

  > padzero(5, 126) = 00126
  > padzero(5, 23) = 00023
  > padzero(1, 23) = 23

}

{
param
Deprecated: use stamp instead.

USAGE
  param(<token>, <value>)

This function is now obsolete, please use stamp instead. A warning will
be generated if used.

RELATED

  * stamp

}

{
parmisstring
Returns 1 if a specified parameter is a string.

USAGE
  parmisstring(<parameter_name>)

EXAMPLES

  > echo `parmisstring("/obj/model/lookatpath")`

}

{
pdgattribute
Returns the value of a work item attribute

USAGE
  pdgattribute(<name>, <index>)
  <name> is the name of the attribute

  <index> is the component index of the attribute


NOTE
    This function is equivalent to doing @<name>.<index>, but makes it
    easier to programtically select the attribute name or index.

EXAMPLES

  > pdgattribute("pdg_frame", 0)
    Returns the frame value of the current work item - equivalent to
    @pdg_frame

  > pdgattribute("color", 2)

    Returns the second component of the "color" attribute.

RELATED

  * pdgattributes

}

{
pdgattributes
Returns the string value of a work item attribute

USAGE
  pdgattributes(<name>, <index>)
  <name> is the name of the attribute

  <index> is the component index of the attribute


NOTE
    This function is equivalent to doing @<name>.<index>, but makes it
    easier to programtically select the attribute name or index.

EXAMPLES

  > pdgattributes("pdg_input", 0)
    Returns the first input file on the active work item. This is
    equivalent to using @pdg_input.

  > pdgattributes("filenames", 2)

    Returns the second component of the "filenames" attribute.

RELATED

  * pdgattribute

}

{
pdginput
Returns a work item input file for the specified index and tag

USAGE
  pdginput(<index>, <tag>, <localize>)
  <name> the input number

  <index> the tag, which can be set to empty string if unspecified

  <localize> set to 1 to indicate that the input file path should have
  PDG directory tokens resolved.


NOTE
    This function is a more generalized version of the @pdg_input
    attribute.

EXAMPLES

  > pdginput(1, "file/image", 0)
    Returns the input image file with index 1.

RELATED

  * pdgoutput

}

{
pdgoutput
Returns a work item output file for the specified index and tag

USAGE
  pdgoutput(<index>, <tag>, <localize>)
  <name> the output file index

  <index> the tag, which can be set to empty string if unspecified

  <localize> set to 1 to indicate that the input file path should have
  PDG directory tokens resolved.


NOTE
    This function is a more generalized version of the @pdg_output
    attribute.

EXAMPLES

  > pdgoutput(1, "", 0)
    Returns the second output file from the active work item, equivalent
    to @pdg_output.1.

RELATED

  * pdginput

}

{
pic

REPLACED BY
  - hou.CopNode.getPixelByUV()
  - hou.CopNode.getPixelHSVByUV()
  - hou.CopNode.getPixelLuminanceByUV()
  - hou.CopNode

Returns the color of a pixel in a compositing node.

USAGE
  pic(<copname>, <U>, <V>, <color_type>)

The color_type parameter can be one of the following: D_CR, D_CG, D_CB,
D_CA, D_CHUE, D_CSAT, D_CVAL, D_CLUM for the red, green, blue, alpha,
hue, saturation, value, or luminance of the pixel.

The color returned will be interpolated smoothly between adjacent
pixels. For the non-interpolated color, use picni.

EXAMPLES

  > pic("/img/img1/color1", .5, .5, D_CLUM)

RELATED

  * picni

  * tex

  * texni

  * res

}

{
picni

REPLACED BY
  - hou.CopNode.getPixelByUV()
  - hou.CopNode.getPixelHSVByUV()
  - hou.CopNode.getPixelLuminanceByUV()
  - hou.CopNode

Returns the non-interpolated color of a pixel in a compositing node.

USAGE
  picni(<copname>, <U>, <V>, <color_type>)

The color_type parameter can be one of the following: D_CR, D_CG, D_CB,
D_CA, D_CHUE, D_CSAT, D_CVAL, D_CLUM for the red, green, blue, alpha,
hue, saturation, value, or luminance of the pixel.

The color returned will not be interpolated. That is, it will be the
exact color of the pixel. For the interpolated color, use pic.

EXAMPLES

  > picni("/img/img1/color1", .5, .5, D_CLUM)

RELATED

  * pic

  * tex

  * texni

  * res

}

{
pluralize
Converts an English noun to its plural.

USAGE
  pluralize(<s>)

}

{
point

REPLACED BY
  - hou.Geometry.iterPoints()
  - hou.Point.attribValue()

Returns the value of a point attribute.

USAGE
  point(<surface_node>, <point_number>, <attribute>, <index>)
  <surface_node> is a path to a surface node, for example
  "/obj/geo1/grid1".

  <point_number> is the point number to read the attribute from. When
  instancing, you can use instancepoint to get the number of the point
  currently being instanced.

  <attribute> is the name of the attribute (for example, Cd for diffuse
  color). Two special attributes exist: P and Pw which represent the
  position of the point in space (Pw allows you to access the W
  component of the position).

  <index> specifies the component position in multi-component attributes
  such as vectors, colors, and arrays. For example, if the attribute is
  a color, an index value of 0 returns the red component, 1 returns the
  green component, and 2 returns the blue component.


NOTE
    This function will interpolate between point values if the point
    number is fractional, such as 3.35

EXAMPLES

  > point("/obj/geo1/facet1", 3, "P", 0)
    Returns the X component of point 3 of the facet1 surface node in
    geo1.

  > point("/obj/geo1/facet1", 3, "N", 2)

    Returns the Z component of the normal attribute of point 3 in the

RELATED

  * pointavg

  * vertex

}

{
pointattribsize

REPLACED BY
  - hou.Attrib.size()

Returns the number of components in a point attribute.

USAGE
  pointattribsize(<surface_node>, <attribute>)

If the surface node or attribute is not found, returns 0.

EXAMPLES

  > pointattribsize( "/obj/model/grid1", "P" )
    Returns 3, the number of components in a "P" (position) attribute
    (X, Y, and Z).

RELATED

  * point

  * vertexattribsize

  * primattribsize

  * detailattribsize

}

{
pointattribtype
Returns the type of a point attribute.

USAGE
  pointattribtype(<surface_node>, <attribute>)

If the surface node or attribute are not found, returns -1.


Types are
  * -1 - Unknown/Invalid

  * 0 - Integer

  * 1 - Float

  * 2 - String

EXAMPLES

  > pointattribsize( "/obj/model/box", "Cd" )
    Returns 1 to denote a float attribute.

RELATED

  * point

  * primattribtype

  * vertexattribtype

  * detailattribtype

}

{
pointavg
Returns the average of an attribute across all points in a geometry.

USAGE
  pointavg(<surface_node>, <attribute>, <index>)

This function works much like the point function, except that it returns
the average value of the attribute for all points in the specified
surface node.

<index> specifies the component position in multi-component attributes
such as vectors, colors, and arrays. For example, if the attribute is a
color, an index value of 0 returns the red component, 1 returns the
green component, and 2 returns the blue component.

}

{
pointdist
Returns the distance between a point and a primitive.

USAGE
  `pointdist(<surface_node>, <point_num>, <surface_node>, <prim_num>,
  <return_type>)`

Given a point and a primitive, this function finds the distance between
the point and the closest spot on the primitive. If prim_num is minus
one, the closest distance to any primitive is found.

  * return_type = 0 returns the minimum distance.

  * return_type = 1 returns the u parametric value at the point of
    minimum distance.

  * return_type = 2 returns the v parametric value at the point of
    minimum distance.

  * return_type = 3 returns the primitive number that was closest. Enter
    -1 as the <prim_num>.

EXAMPLES

  > pointdist("/obj/geo1/add1", 0, "/obj/geo1/grid1", 0, 0)
    Returns the distance between point 0 of add1 and the closest spot
    from the surface of grid1 primitive number 0. If the return_type
    were 1, the u parametric value that is closest to the point would be
    returned.

RELATED

  * primdist

  * xyzdist

  * nearpoint

}

{
pointgrouplist

REPLACED BY
  - hou.Geometry.pointGroups()

Returns the list of point groups in a surface node.

USAGE
  pointgrouplist(<surface_node>)

The returned string is a space separated list of group names.

To get a list of groups whose names match a pattern, use pointgroupmask.

RELATED

  * haspoint

  * pointlist

  * hasprim

  * primlist

  * primgrouplist

  * pointgroupmask

}

{
pointgroupmask
Returns the list of point groups matching a pattern in a surface node.

USAGE
  pointgroupmask(<surface_node>, <pattern>)

The returned string is a space separated list of group names.

To simply get a list of all point groups (no pattern), use
pointgrouplist.

EXAMPLES

  > pointgroupmask("/obj/model", "group*")
    Returns the names of all point groups in the specified surface node
    which start with "group". So this may be something like "group1
    group2 group_smoke".

RELATED

  * haspoint

  * pointlist

  * pointgrouplist

}

{
pointlist

REPLACED BY
  - hou.Geometry.iterPoints()
  - hou.Point.number()
  - hou.PointGroup
  - hou.Prim.number()

Returns a list of all points in a point group.

USAGE
  pointlist(<surface_node>, <group_name>)

The returned string is a space separated list of point numbers.

RELATED

  * haspoint

  * pointgrouplist

  * pointpattern

  * hasprim

  * primlist

  * primgrouplist

}

{
pointneighbours
Lists points that share a minimum number of primitives with a specified
point.

USAGE
  pointneighbours(<surface_node>, <point_num>, <num_shared_prims>)

This function lists all the points that share at least
<num_shared_prims> primitives with the point specified by <point_num>.

The returned string is a space separated list of point numbers.

EXAMPLES

  > pointneighbours("/obj/geo1/sphere1", 88, 2)
    Returns a list of numbers that identify the points in sphere1 that
    share at least 2 primitives (typically along an edge) with sphere1
    point number 88.

  > pointneighbours("/obj/geo1/sphere1", 88, 1)

    Returns a list of numbers that identify the points in sphere1 that
    share at least 1 primitive with sphere1 point number 88.

  > pointneighbours("/obj/geo1/sphere1", 88, 0)

    Returns a list of all the points in sphere1 except point number 88.

RELATED

  * primneighbours

}

{
pointpattern

REPLACED BY
  - hou.Geometry.globPoints()

Returns a list of points that match a specified pattern.

USAGE
  pointpattern(<surface_node>, <pattern>)

The pattern is a space separated list of point numbers, point number
ranges, or point group names.

The returned string is a space separated list of point numbers.

EXAMPLES

  > pointpattern("/obj/model/sphere1", "2-5 10-12")
    Returns "2 3 4 5 10 11 12", assuming the specified surface node
    exists and has that many points.

  > pointpattern("/obj/model/group1", "10 group1 20")

    Returns a list of all points in the group named "group", as well as
    10 and 20. The order of the returned points is not guaranteed.

RELATED

  * pointlist

}

{
points

REPLACED BY
  - hou.Geometry.iterPoints()
  - hou.Point.attribValue()

Returns the string value of a point attribute.

USAGE
  points(<surface_node>, <point_number>, <attribute>)

EXAMPLES

  > points("/obj/geo1/facet1", 3, "instance")
    Returns the string associated with the string attribute "instance"
    for point 3 in the facet1 surface node in geo1.

}

{
pointsmap
Returns a string from a list of strings in a point attribute.

USAGE
  pointsmap(<surface_node>, <attribute>, <index>)

This function will return the <index>th unique string bound to the given
point attribute. Use pointsnummap to find the total number of unique
strings. Note that the exact order of the strings is should not be
relied upon. The indexes start with 0 and go to pointsnummap()-1.

EXAMPLES

  > pointsmap("/obj/geo1/attribcreate1", "foo", 0)
    Returns the first unique string on the given surface node.

}

{
pointsnummap
Returns the number of unique strings bound to a point attribute.

USAGE
  pointsnummap(<surface_node>, <attribute>)

EXAMPLES

  > pointsnummap("/obj/geo1/attribcreate1", "foo")
    Returns number of unique strings in the foo attribute.

}

{
pow
Raises a number to an exponent.

USAGE
  pow(<base>, <exponent>)

EXAMPLES

  > pow(2, 3) = 8

}

{
prim

REPLACED BY
  - hou.Geometry.prims()
  - hou.Prim.attribValue()

Returns the value of a primitive attribute.

USAGE
  prim(<surface_node>, <prim_num>, <attrib_name>, <attrib_index>)

When given the "P" or "Pw" attribute, returns the centroid of the
primitive.

This can also be used to read the value of a primitive intrinsic by
specifying "intrinsic:name_of_intrinsic" instead of an attribute name.

EXAMPLES

  > prim("/obj/geo1/facet1", 3, "P", 0)
    Evaluates the X component of the centroid of primitive 3 in the
    specified surface node.

  > prim("/obj/geo1/facet1", 3, "Cd", 1)

    Evaluate the green color of the "Cd" attribute of primitive 3.

RELATED

  * primuv

  * point

}

{
primattribsize

REPLACED BY
  - hou.Attrib.size()

Returns the number of components in a primitive attribute.

USAGE
  primattribsize(<surface_node>, <attribute>)

If the surface node or attribute are not found, returns 0.

EXAMPLES

  > primattribsize( "/obj/model/box", "Cd" )
    Returns the number of elements of a diffuse color attribute.

RELATED

  * prim

  * pointattribsize

  * vertexattribsize

  * detailattribsize

}

{
primattribtype
Returns the type of a primitive attribute.

USAGE
  primattribtype(<surface_node>, <attribute>)

If the surface node or attribute are not found, returns -1.


Types are
  * -1 - Unknown/Invalid

  * 0 - Integer

  * 1 - Float

  * 2 - String

EXAMPLES

  > primattribsize( "/obj/model/box", "Cd" )
    Returns 1 to denote a float attribute.

RELATED

  * prim

  * pointattribtype

  * vertexattribtype

  * detailattribtype

}

{
primdist
Returns the minimum distance and closest points between two primitives.

USAGE
  `primdist(<surface_node>, <prim1_num>, <surface_node>, <prim2_num>,
  <return_type>)`

  * <return_type> = 0: minimum distance

  * <return_type> = 1: U value of closest point on primitive 1

  * <return_type> = 2: V value of closest point on primitive 1

  * <return_type> = 3: U value of closest point on primitive 2

  * <return_type> = 4: V value of closest point on primitive 2

Only works for faces, curves, and spline surfaces. Other types of
primitives will always return 0.


NOTE
    Minimum works in two groups. You can either use minimum between
    curves and polygons or between meshes, nurbs surfaces, and bezier
    surfaces. However, it will not work between the two groups. For
    example, a NURBS curve + NURBS surface will not work.

EXAMPLES

  > primdist("/obj/geo1/sphere1", 0, "/obj/geo1/grid1", 0, 0)
    Returns the distance between the first primitives in both sphere1
    and grid1.

RELATED

  * pointdist

  * xyzdist

  * nearpoint

}

{
primduv

REPLACED BY
  - hou.Surface.attribValueAt()

Returns the partial derivatives of a primitive attribute.

USAGE
  `primduv(<surface_node>, <prim_num>, <attrib_name>, <attrib_index>,
  <u>, <v>, <du>, <dv>)`

Evaluates the (partial) derivatives of a face or hull attribute at a
parametric (u,v) position. u and v are unit values, defined in the [0,1]
interval. When given the "P" or "Pw" attribute, the positional
derivative of (u,v)'s image on the primitive will be returned. If the
primitive is a face type, v and dv are ignored. If both du and dv are 0,
primduv becomes equivalent to primuv.


NOTE
    if the primitive is a polygon or a mesh, u and v are defined in
    terms of the number of vertices, or rows or columns respectively.

EXAMPLES

  > primduv("/obj/geo1/tube1", 12, "P", 2, 0.4, 0.5, 1, 0)
    Evaluates the Z component of the first-order partial derivative of
    primitive 12 with respect to u, at the parametric location
    (0.4,0.5).

RELATED

  * primuv

  * normal

  * curvature

  * unituv

}

{
primgrouplist

REPLACED BY
  - hou.Geometry.primGroups()

Returns the list of primitive groups in a surface node.

USAGE
  primgrouplist(<surface_node>)

The returned string is a space separated list of group names.

RELATED

  * haspoint

  * pointlist

  * pointgrouplist

  * hasprim

  * primlist

  * primgroupmask

}

{
primgroupmask
Returns the list of groups matching a pattern in a surface node.

USAGE
  primgroupmask(<surface_node>, <pattern>)

The returned string is a space separated list of group names.

To simply get a list of all primitive groups (no pattern), use
primgrouplist.

EXAMPLES

  > primgroupmask("/obj/model", "group*")
    Returns the names of all primitive groups in the specified surface
    node which start with "group". So this may be something like "group1
    group2 group_leftleg".

RELATED

  * hasprim

  * primlist

  * primgrouplist

}

{
primlist

REPLACED BY
  - hou.Geometry.prims()
  - hou.Prim.number()
  - hou.PrimGroup

Returns a list of all primitives in a surface node.

USAGE
  primlist(<surface_node>, <group_name>)

The return string is a space separated list of primitive numbers.

RELATED

  * haspoint

  * pointlist

  * pointgrouplist

  * hasprim

  * primgrouplist

}

{
primneighbours
Lists primitives that share a minimum number of points with a specified
primitive.

USAGE
  primneighbours(<surface_node>, <prim_num>, <num_shared_pts>)

This function lists all the primitives that share at least the given
number of points with the primitive specified.

The returned string is a space separated list of primitive numbers.

EXAMPLES

  > primneighbours("/obj/geo1/sphere1", 88, 2)
    Returns a list of numbers that identify the primitives in sphere1
    that share at least 2 points (typically along an edge) with sphere1
    primitive number 88.

  > primneighbours("/obj/geo1/sphere1", 88, 1)

    Returns a list of numbers that identify the primitives in sphere1
    that share at least 1 point with sphere1 primitive number 88.

  > primneighbours("/obj/geo1/sphere1", 88, 0)

    Returns a list of all the primitives in sphere1 except primitive
    number 88.

RELATED

  * pointneighbours

}

{
prims

REPLACED BY
  - hou.Geometry.prims()
  - hou.Prim.attribValue()

Returns the string value of a primitive attribute.

USAGE
  prims(<surface_node>, <primitive_number>, <attribute>)

This can also be used to read the value of a primitive intrinsic by
specifying "intrinsic:name_of_intrinsic" instead of an attribute name.

EXAMPLES

  > prims("/obj/geo1/facet1", 3, "texturemap")
    Returns the string associated with the string attribute "texturemap"
    for primitive 3 in the facet1 surface node in geo1.

}

{
primsmap
Returns a string from a list of strings in a primitive attribute.

USAGE
  primsmap(<surface_node>, <attribute>, <index>)

This function will return the <index>th unique string bound to the given
prim attribute. Use primsnummap to find the total number of unique
strings. Note that the exact order of the strings is should not be
relied upon. The indexes start with 0 and go to primsnummap()-1.

EXAMPLES

  > primsmap("/obj/geo1/attribcreate1", "foo", 0)
    Returns the first unique string in the foo attribute.

}

{
primsnummap
Returns the number of unique strings bound to a primitive attribute.

USAGE
  primsnummap(<surface_node>, <attribute>)

EXAMPLES

  > primsnummap("/obj/geo1/attribcreate1", "foo")
    Returns number of unique strings tied to the foo attribute.

}

{
primuv

REPLACED BY
  - hou.Face.positionAt()
  - hou.Face.attribValueAt()
  - hou.Prim.positionAtInterior()
  - hou.Prim.attribValueAtInterior()
  - hou.Surface.positionAt()
  - hou.Surface.attribValueAt()

Returns the value of a primitive attribute at a certain UV location.

USAGE
  `primuv(<surface_node>, <prim_num>, <attrib_name>, <attrib_index>,
  <u>, <v>)`

Evaluates the specified attribute at a parametric (u,v) position on the
primitive. u and v are unit values, defined in the [0,1] interval. When
given the "P" or "Pw" attribute, the x, y, or z image of the (u,v)
domain point will be returned. If the primitive is a face type or a
circle, v is ignored.


NOTE
    if the primitive is a polygon or a mesh, u and v are defined in
    terms of the number of vertices, or rows or columns respectively.
    Currently, only the position attribute of quadric primitives can be
    evaluated.

EXAMPLES

  > primuv("/obj/geo1/tube1", 0, "Cd", 1, 0.7, 0.3)
    Evaluates the Green component of the diffuse color attribute at a
    location on primitive 0 given by the parametric coordinates
    (0.7,0.3).

RELATED

  * primduv

  * normal

  * curvature

  * unituv

}

{
print
Prints a message to the console.

USAGE
  print(<label>, <expression>)

This is useful diagnose parameters in nodes or channels.

Returns the value of <expression>.

EXAMPLES

  > print("wheel:", sin($T))

}

{
property
Similar to ch(), but for render properties, with a default if the
property doesn't exist.

USAGES
  property("<path>", <default>)
  propertyf("<path>", <frame>, <default>)
  propertyt("<path>", <time>, <default>)
  propertys("<path>", "<default>")
  propertysop("<path>", "<default>")
  propertysraw("<path>", "<default>")

The property, propertyf, propertyt, propertys, propertysop, and
propertysraw functions are equivalent to the ch, chf, cht, chs, chsop,
and chsraw function but for evaluating render properties.

The first argument is a path to a property on a node. Unlike their ch*
counterparts, these functions take an extra <default> argument which the
function returns if the property/parameter doesn't exist on the node.

For example, for an object where the vm_pointscale attribute exists, but
the vm_samplecovingexpansion property doesn't exist, you can get a
default value back using the property() function:

> property("/obj/geo1/vm_pointscale", 2.0) == 1
> property("/obj/geo1/vm_samplecovingexpansion,", 0.2) == 0.2

If you use the ch() function, it will silently fails and return 0 if the
property doesn't exist:

> ch("/obj/geo1/vm_pointscale") == 1
> ch("/obj/geo1/vm_samplecovingexpansion,") == 0

See the equivalent ch function for more information on each variant.

RELATED


    ch
    chf
    cht
    chs
    chsop
    chsraw

}

{
propertyf
Evaluates a render property at a given frame.

See property.

}

{
propertys
Evaluates the string value of a render property at the current time.

See property.

}

{
propertysop
Evaluates a render property at the current time as a node path string.

See property.

}

{
propertysraw
Evaluates the raw (unexpanded) string value of a render property at the
current time.

See property.

}

{
propertyt
Evaluates a render property at a given time.

See property.

}

{
pulse
Returns 1 when a value is within a certain range.

USAGE
  pulse(<value>, <start>, <end>)

If the value is less than start or greater than end, pulse returns a 0.
Otherwise, it returns 1.

Frequently, start and end are frame numbers and val is based on the
current frame, $F. Using the modulus operator (%) you can set up a pulse
that turns on and off repeatedly as the frame changes. For example, to
blink on for 5 frames and then off for five frames repeated (i.e. return
1 for frames 0 to 4, then 0 for frames 5 to 9, then 1 for frames 10 to
14, etc.), use:

> pulse($F % 10, 0, 4)
}

{
pythonexprf
Evaluates a Python expression, returning a float result.

USAGE
  pythonexprf(<expression>)

If the expression evaluates to something other than a string, or if it
raises an exception, this function returns 0.

EXAMPLES

  > pythonexprf("hou.frame()")
    Returns the current frame number.

RELATED

  * python

  * pythonexprs

}

{
pythonexprs
Evaluates a Python expression, returning a string result.

USAGE
  pythonexprs(<expression>)

If the expression evaluates to something other than a string, this
function returns its string representation (i.e. the output from
Python's str() function).


NOTE
    If the expression generates an exception, this function returns the
    string representation of the exception.

EXAMPLES

  > pythonexprs("hou.node('/obj').children()")
    Returns the string representation of a tuple containing the
    hou.ObjectNode objects in /obj.

RELATED

  * python

  * pythonexprf

}

{
qlinear

REPLACED BY
  - hou.qlinear()

Channel segment function: uses quaternions to interpolate.

USAGE
  qlinear()

A channel expression function which uses quaternions to interpolate
between the keyframed values. This function requires that it has two
neighboring channels named appropriately. This means they should end
with x, y, and z, or be three consecutive numbers starting from 0 (such
as 0, 1, 2, or 6, 7, 8).

Because the interpolation is done in quaternion space, the orientations
will blend smoothly with no gimbal lock or unexpected spins. However,
the rotation values may appear to jump suddenly. This is because
different rotation values can represent the same orientation.

Note in the graph editor a segment using this expression will show as a
dashed straight line. This does not represent the actual intermediate
channel values, but does give an accurate visual feel for the behavior
of the interpolation.

}

{
quattomatrix
Converts quaternion to a 3x3 rotation matrix.

USAGE
  quattomatrix(<q>)

RELATED

  * matrixtoquat

}

{
quintic

REPLACED BY
  - hou.quintic()

Channel segment function: smoothly interpolates slopes and
accelerations.

USAGE
  quintic()

}

{
rad

REPLACED BY
  - hou.hmath.degToRad()

Converts from degrees to radians.

USAGE
  rad(<number>)

EXAMPLES

  > rad (180)=3.1415926

}

{
rand

REPLACED BY
  - hou.hmath.rand()

Returns a pseudo-random number from 0 to 1.

USAGE
  rand(<value>)

Using the same <value> always gives the same result. To vary the result,
base the <value> on a changing number (usually the current frame $F).

> rand($F)

When you're randomizing component values (such as X, Y, and Z), change
the <value> for each component so they don't all get the same number:


X
    rand($F)

Y
    rand($F * 0.1)

Z
    rand($F * 0.01)


NOTE
    It is a good idea to use non-integer values as the argument to
    rand().

}

{
raw
Channel segment function.

USAGE
  raw()

}

{
realuv
Converts unit UV to real UV.

USAGE
  realuv(<surface_node>, <prim_num>, <uv_unit>, <D_U|D_V>)

The unit value is defined in the [0,1] interval. The real value is
defined in the valid interval of the primitive's domain if the primitive
is a spline type. If the primitive is a polygon or a mesh, the size of
its domain is given by the number of vertices, or rows or columns
respectively. If the primitive is a polygon or a curve, D_U and D_V are
irrelevant.


NOTE
    the result is undefined if the primitive is neither a face nor a
    hull.

RELATED

  * unituv

}

{
repeat

REPLACED BY
  - hou.repeat()

Channel segment function: repeats animation from previous frames.

USAGE
  repeat(<f1>, <f2>)

Repeats the animation from frames <f1> to <f2>.

If you wish to repeat the animation cumulatively, use the cycle function
instead.

RELATED

  * repeatt

  * cycle

  * cyclet

}

{
repeatt

REPLACED BY
  - hou.repeatt()

Channel segment function: repeats animation from previous frames.

USAGE
  repeatt(<t1>, <t2>)

Repeats the animation from <t1> seconds to <t2> seconds.

If you wish to repeat the animation cumulatively, use the cyclet
function instead.

RELATED

  * repeat

  * cycle

  * cyclet

}

{
res

REPLACED BY
  - hou.CopNode

Returns the natural resolution of the image in a compositing node.

USAGE
  res(<compositing_node>, <res_type>)

<res_type> is either D_XRES or D_YRES.

EXAMPLES

  > res("/img/img1/color1", D_XRES)

}

{
rgb

REPLACED BY
  - hou.Color

Converts HSV values to RGB components.

USAGE
  rgb(<hue>, <saturation>, <value>, <component>)

The <component> should be one of "r", "g" or "b".

EXAMPLES

  > rgb(270, .5, 1, "b")

}

{
rindex
Finds the last occurrence of a pattern in a string.

USAGE
  rindex(<source>, <pattern>)

Returns the number of characters before <pattern> occurs in <source>.
Returns -1 if the pattern is not found.

EXAMPLES

  > echo `rindex("Testing rindex", "sting")`
    Returns 2.

  > echo `rindex("Testing rindex", "i")`

    Returns 8.

RELATED

  * index

}

{
rint
Rounds to the nearest integer.

USAGE
  rint()

RELATED

  * round

}

{
rotate

REPLACED BY
  - hou.hmath.buildRotate()

Returns a 4x4 rotation matrix from an axis and angle.

USAGE
  rotate(<angle>, <axis>)

<angle> is in degrees.

<axis> is one of "x", "y", or "z".

RELATED

  * rotaxis

  * scale

  * translate

}

{
rotaxis

REPLACED BY
  - hou.hmath.buildRotateAboutAxis()

Returns a 4x4 rotation matrix from an angle and a vector.

USAGE
  rotaxis(<angle>, <axisv>)

<angle> is in degrees.

The rotation is taken from the angle around the axis specified by the
vector <axisv>. The vector is converted to a 3 vector for the purposes
of this computation.

Houdini's expression language uses row vectors. Rotation matrices should
appear on the right-hand side of vector-matrix multiplications.

For example, to rotate the vector [1, 2, 3] by 10 degrees around the Y
axis:

> vector("[1, 2, 3]") * rotaxis(10, "[0, 1, 0]")

RELATED

  * rotate

  * scale

  * translate

}

{
round
Rounds a number to the nearest integer.

USAGE
  round()

EXAMPLES

  > round(2.501)=3
  > round(-2.501)=-3
  > round(0.2)=0
  > round(-.2)=0

RELATED

  * trunc

  * int

  * ceil

  * floor

  * frac

}

{
run
Runs a string as an HScript command and returns the command's output.

USAGE
  run(<command>)

This is a short form for the execute function.

RELATED

  * execute

  * rune

  * runb

}

{
runb
Runs a string as an HScript command and returns the command and error
output.

USAGE
  runb(<command>)

This is a short form for the executeb function.

RELATED

  * executeb

  * run

  * rune

}

{
rune
Runs a string as an HScript command and returns any error output.

USAGE
  rune(<command>)

This is a short form for the executee function.

RELATED

  * executee

  * run

  * runb

}

{
scale

REPLACED BY
  - hou.hmath.buildScale()

Takes three scaling values and returns a scale matrix.

USAGE
  scale(<sx>, <sy>, <sz>)

RELATED

  * rotate

  * rotaxis

  * translate

}

{
seampoints
Lists all seam points in a surface node.

USAGE
  seampoints(<surface_node>, <whichside>)

This function returns a string containing an ordered list of all seam
points in the specified surface node. Seam points are identified by seam
attributes on the points.

The <whichside> argument specifies which side of the seams we are
interested in. The value can be either zero or one.

Calling this function once with a whichside parameter of zero, and once
with a whichside parameter of one, will provide two lists of points
where tying each point to the corresponding point in the other list
fully describes all seams on the geometry.

RELATED

  * pointlist

  * pointpattern

}

{
seqanim

REPLACED BY
  - hou.CopNode.isSingleImage()
  - hou.CopNode

Returns 1 if a specified compositing node has an animated sequence.

USAGE
  seqanim(<compositing_node>)

Returns 0 if <compositing_node> has a single image.

RELATED

  * seqstart

  * seqend

  * seqlength

}

{
seqend

REPLACED BY
  - hou.CopNode.sequenceEndFrame()
  - hou.CopNode

Returns the end frame of a compositing node's image sequence.

USAGE
  seqend(<compositing_node>)

RELATED

  * seqanim

  * seqstart

  * seqlength

}

{
seqlength

REPLACED BY
  - hou.CopNode.sequenceFrameLength()
  - hou.CopNode

Returns the number of frames in a compositing node's image sequence.

USAGE
  seqlength(<compositing_node>)

RELATED

  * seqanim

  * seqstart

  * seqend

}

{
seqstart

REPLACED BY
  - hou.CopNode.sequenceStartFrame()
  - hou.CopNode

Returns the start frame of a compositing node's image sequence.

USAGE
  seqstart(<compositing_node>)

RELATED

  * seqanim

  * seqend

  * seqlength

}

{
shopstring

REPLACED BY
  - hou.ShopNode.shaderString()

Returns the shader string generated by a shader.

USAGE
  shopstring(<shop_path>, <render_type>)

The <render_type> is a string representing the renderer ("RIB" or
"VMantra" for example). If this string is empty, then the default render
type for the shader is used.

}

{
sign

REPLACED BY
  - hou.hmath.sign()

Returns -1, 0, or 1 depending on the sign of the argument.

USAGE
  sign(<value>)

Returns 1 if <value> is positive, -1 if <value> is negative, and 0 if
the <value> is zero.

}

{
sin
Returns the sine of the argument.

USAGE
  sin(<degrees>)

EXAMPLES

  > sin (60)=0.866025

}

{
sinh
Returns the hyperbolic sine of the argument.

USAGE
  sinh(<number>)

}

{
smooth

REPLACED BY
  - hou.hmath.smooth()

Takes a value and range and returns a smooth interpolation between 0 and
1.

USAGE
  smooth(<value>, <minimum>, <maximum>)

When <value> is less than <minimum>, the return value is 0. If <value>
is greater than <maximum>, the return value is 1.

EXAMPLES

  > smooth ($F, 12, 55)
    This example will generate an ease-type curve between values 0 and
    1, starting at frame 12 and ending at frame 55. Dig it!

}

{
snoise
Generates sparse convolution 3D noise.

USAGE
  snoise(<X>, <Y>, <Z>)

The noise is generated on points scattered in space and interpolated
between the points in the voronoi decomposition. The output of the noise
function is approximately -1.15 to 1.15.

> snoise($TX, $TY, $TZ)

RELATED

  * noise

  * turb

  * sturb

}

{
spknot
Returns a knot value on a spline curve or surface.

USAGE
  spknot(<surface_node>, <prim_num>, <knot_index>, D_U|D_V)

This spline-specific function returns the floating-point knot value,
given the knot index in the U or V knot sequence. The first valid knot
index is 0. If the primitive is a Bezier curve or surface, the values
returned are those of its breakpoints.

If the primitive is a curve, the fourth argument (D_U or D_V) is
irrelevant.

}

{
spline

REPLACED BY
  - hou.spline()

Channel segment function: fits a curve to the keyframes.

USAGE
  spline()

A channel expression function which runs a spline through the timemarks
of the consecutive channel segments that use that function. That is,
this spline interpolates the channel values at the keyframes of the
segments.

RELATED

  * bezier

  * cubic

}

{
sqrt
Returns the square root of the argument.

USAGE
  sqrt(<number>)

EXAMPLES

  > sqrt (144)=12

}

{
stamp

REPLACED BY
  - hou.Node.stampValue()

Returns a copy stamping floating point value.

USAGE
  stamp(<scope>, <token>, <value>)

Retrieves a stamping variable, usually from a downstream Copy node. See
copy stamping.

This function retrieves floating-point number values. For string values,
use stamps.

  * <scope>: the path of the node to get the value from.

  * <token>: the name of the variable to retrieve.

  * <value>: the default value to use if <token> does not exist.

Examples of stamping operators include: Cache, Copy, and LSystem surface
nodes, and the Copy channel node.

EXAMPLES

  > stamp("../copy1", "sides", 5)
  > stamp("..", "fuzzy", 0.5)

}

{
stamps

REPLACED BY
  - hou.Node.stampValue()

Returns a copy stamping string value.

USAGE
  stamps(<stamp_op_path>, <token>, <value>)

Retrieves a stamping variable. See copy stamping.


NOTE
    This expression does not work with the Copy SOP.

This function retrieves string values. For floating-point number values,
use stamp.

  * <scope>: the path of the node to get the value from.

  * <token>: the name of the variable to retrieve.

  * <value>: the default string to use if <token> does not exist.

Returns the string value associated with the parameter named 'token' set
in 'scope'. 'scope' is an operator path where the value is to be looked
up from. If the token has not been set, then 'value' is returned.
Stamping operators set these named tokens parameters recursively on
themselves and all ancestor parents.

Examples of string stamping operators include the Apply Relationship
DOP, and the Copy Data DOP.

EXAMPLES

  > stamps("../copydata1", "name", "defaultname")

}

{
strcasecmp
Compares two strings, ignoring case.

USAGE
  strcasecmp(<s1>, <s2>)

  * Returns -1 if <s1> comes before <s2> according to ASCII.

  * Returns 1 if <s1> comes after <s2> according to ASCII.

  * Returns 0 if <s1> is equal to <s2>.

This function is case-insensitive. For case-sensitive comparison, use
strcmp.

RELATED

  * strcmp

  * strmatch

  * strcasematch

}

{
strcasematch
Returns 1 if a string matches a pattern, ignoring case.

USAGE
  strcasematch(<pattern>, <s>)

This function is case-insensitive. For case-sensitive matches, use
strmatch.

NOTES

  * Returns 1 if any patterns in the <pattern> string matches string
    <s>, or 0 if no patterns match.

  * In order to match, a pattern must match the <s> string _from
    beginning to end_. Use wildcards (*) to match substrings, e.g.

      > strmatch("bar", "foobarbaz") = 0
      > strmatch("*bar*", "foobarbaz") = 1
  * <pattern> is a space-separated list of one or more patterns. *This
    can cause unintuitive behavior of this function*. For example:

      > strmatch("foo bar", "foo bar")
        ...*will return 0*, because the first argument consists of _two_
        patterns, foo and bar, and neither of those patterns match foo
        bar (since the pattern must match from beginning to end).

        Similarly,

      > strmatch("foo bar", "foo")

        ...will return 1, because the string matches the first of the
        two arguments in the pattern (foo and bar).

EXAMPLES

  > strmatch("FOO*", "foobar")
    Returns 1.

  > strmatch("?baR", "fred")

    Returns 0.

  > strmatch("FoO*,bAr*, "bar")

    Returns 1.

RELATED

  * strcmp

  * strcasecmp

  * strcasematch

}

{
strcat
Returns the concatenation of two strings.

USAGE
  strcat(<s1>, <s2>)

EXAMPLES

  > strcat("Current motion file is ", $MOTNAME)
    Returns "Current motion file is job1.bmot"

}

{
strcmp
Compares two strings.

USAGE
  strcmp(<s1>, <s2>)

  * Returns -1 if <s1> comes before <s2> according to ASCII.

  * Returns 1 if <s1> comes after <s2> according to ASCII.

  * Returns 0 if <s1> is equal to <s2>.

This function is case-sensitive. For case-insensitive comparison, use
strcasecmp.

EXAMPLES

  > strcmp("abc", "xyz") = -1
  > strcmp("A", "a") = -1
  > strcmp("xyz, "abc") = 1
  > strcmp("abc", "abc") = 0

}

{
strdup
Duplicates a string.

USAGE
  strdup(<count>, <s2>)

Returns <s2> repeated <count> times.

EXAMPLES

  > strdup(3, "abc") = "abcabcabc"
  > strdup(0, "Foobar") = ""
  > strdup(3, "/(120)[B]") = "/(120)[B]/(120)[B]/(120)[B]"

}

{
stripmatrix
Strips non-essential characters from the string representation of a
matrix or vector.

USAGE
  stripmatrix(<mat>)

This is useful when you want to interpret the values of the matrix (i.e.
to pass to a VEX function).

Returns a string containing the floating point numbers (and only the
numbers) which make up the matrix.

EXAMPLES

  > stripmatrix(identity(3)) = "1 0 0 0 1 0 0 0 1"
  > stripmatrix(vector3(1,2,3)) = "1 2 3"

}

{
Returns the number of characters in a string.

strlen

USAGE
  strlen()

EXAMPLES

  > strlen("abcde")=5

}

{
strmatch
Returns 1 if a string matches a pattern, including case.

USAGE
  strmatch(<pattern>, <s>)

This function is case-sensitive. For case-insensitive matches, use
strcasematch.

NOTES

  * Returns 1 if any patterns in the <pattern> string matches string
    <s>, or 0 if no patterns match.

  * In order to match, a pattern must match the <s> string _from
    beginning to end_. Use wildcards (*) to match substrings, e.g.

      > strmatch("bar", "foobarbaz") = 0
      > strmatch("*bar*", "foobarbaz") = 1
  * <pattern> is a space-separated list of one or more patterns. *This
    can cause unintuitive behavior of this function*. For example:

      > strmatch("foo bar", "foo bar")
        ...*will return 0*, because the first argument consists of _two_
        patterns, foo and bar, and neither of those patterns match foo
        bar (since the pattern must match from beginning to end).

        Similarly,

      > strmatch("foo bar", "foo")

        ...will return 1, because the string matches the first of the
        two arguments in the pattern (foo and bar).

EXAMPLES

  > strmatch("foo*", "foobar") = 1
  > strmatch("?bar", "fred") = 0
  > strmatch("foo*,bar*", "bar") = 1

RELATED

  * strcmp

  * strcasecmp

  * strcasematch

}

{
strreplace
Replaces substrings with a new string.

USAGE
  strreplace(<s>, <old>, <new>)

Returns a copy of <s> with any occurances of the <old> string replaces
with the <new> string.

EXAMPLES

  > echo `strreplace("/project/project.hip", "project", "char01")`
    Returns /char01/char01.hip.

}

{
sturb
Generates spatially coherent 3D noise based on sparse convolution.

USAGE
  sturb(<X>, <Y>, <Z>, <depth>)

Spatially coherent noise gives random numbers which are close to each
other when the X, Y, Z inputs are close to each other.

<depth> is the amount of fractalization of the noise.

This is very similar to turb, except instead of finding noise values on
a fixed lattice and interpolating, this function finds noise values on
points scattered in space and interpolated according to the Voronoi
decomposition.

RELATED

  * turb

  * noise

  * snoise

}

{
substr
Returns a substring of a string.

USAGE
  substr(<s>, <start>, <length>)

Returns the characters of <s> between the <start> position and the
<start> + <length> position.

EXAMPLES

  > echo `substr("STRING", 3, 1)`
    Returns I.

  > echo `substr("STRING", 0, 3)`

    Returns STR.

  > echo `substr("STRING", 3, 2)`

    Returns IN.

}

{
surflen
Returns the length of the 3D curve between two points on a surface.

USAGE
  `surflen(<surface_node>, <prim_num>, <ustart>, <vstart>, <ustop>,
  <vstop>)`

Given a surface and two parametric points in its domain (
[ustart,vstart] and [ustop,vstop] ), surflen computes the length of the
3D curve that stretches between the two points. This curve is the 3D
image of the line in the surface domain, whose end-points are
[ustart,vstart] and [ustop,vstop]. If either u or v is kept constant,
the 3D curve coincides with an isoparm.

All four uv numbers are unit values, defined in the [0,1] interval.


NOTE
    the primitive must be either a NURBS surface or a Bezier surface. A
    polygonal mesh can be simulated by a bi-linear Bezier surface (u and
    v order 2).

EXAMPLES

  > surflen("/obj/geo1/grid1", 12, 0, 1, 0.2, 0.8)
    Computes the length of the curve on surface #12, defined
    parametrically by the surface domain points [0,1] and [0.2, 0.8].

RELATED

  * arclen

  * normal

  * curvature

  * unituv

}

{
system
Runs a system command line and returns the output.

This will transform all linefeeds and carriage returns into spaces. To
get the raw output, use systemRAW.

USAGE
  system(<command_string>)

EXAMPLES

  > system("finger")

}

{
systemES
Runs a system command line and returns the exit status.

USAGE
  systemES(<command_string>)

This function returns the _exit code_ of the command. To get the
_output_ of the command instead, use system.

EXAMPLES

  > systemES("test -r $HOME/houdini/123.cmd") = 0

}

{
systemRAW
Runs a system command line and returns the output with no processing.

Unlike the system command, this does not transform linefeeds or carriage
returns into spaces.

USAGE
  systemRAW(<command_string>)

EXAMPLES

  > systemRAW("cat myfile.txt")

}

{
tan
Returns the tangent of the argument.

USAGE
  tan(<degrees>)

EXAMPLES

  > tan (60)=1.73205

}

{
tanh
Returns the hyperbolic tangent of the argument.

USAGE
  tanh(<number>)

}

{
tex
Returns the interpolated color of a point on an on-disk texture map.

USAGE
  tex(<filename>, <U>, <V>, <color_type>)

Textures can be 1, 3 or 4 channel images containing 8-bit, 16-bit or
floating point data.

<color_type> can be one of:

  * r, R, or D_CR = Red channel

  * g, G, or D_CG = Green channel

  * b, B, or D_CB = Blue channel

  * a, A, or D_CA = Alpha channel

  * h, H, or D_CHUE = Color hue

  * s, S, or D_CSAT = Color saturation

  * v, V, or D_CVAL = Color value

  * l, L, or D_CLUM = Color luminance

This function will interpolate colors smoothly between pixels. For the
non-interpolated version, use texni.

When the color component asked for doesn't match the format of the
image, some default behaviour will be taken.

EXAMPLES

  > tex("Mandril.pic", $BBX, $BBY, r).

RELATED

  * texni

  * pic

  * picni

}

{
texni
Returns the non-interpolated color of a point on an on-disk texture map.

USAGE
  texni(<diskfile>, <U>, <V>, <color_type>)

Textures can be 1, 3 or 4 channel images containing 8-bit, 16-bit or
floating point data.

<color_type> can be one of:

  * r, R, or D_CR = Red channel

  * g, G, or D_CG = Green channel

  * b, B, or D_CB = Blue channel

  * a, A, or D_CA = Alpha channel

  * h, H, or D_CHUE = Color hue

  * s, S, or D_CSAT = Color saturation

  * v, V, or D_CVAL = Color value

  * l, L, or D_CLUM = Color luminance

This function will _not_ interpolate colors between pixels. For the
interpolated version, use tex.

When the color component asked for doesn't match the format of the
image, some default behaviour will be taken.

EXAMPLES

  > texni("Mandril.pic", $BBX, $BBY, r).

RELATED

  * tex

  * pic

  * picni

}

{
tolower
Returns the all-lowercase version of a string.

USAGE
  tolower(<s>)

RELATED

  * toupper

}

{
toupper
Returns the all-uppercase version of a string.

USAGE
  toupper(<s>)

RELATED

  * tolower

}

{
translate

REPLACED BY
  - hou.hmath.buildTranslate()

Takes X, Y, and Z translation values and returns a translation matrix.

USAGE
  translate(<tx>, <ty>, <tz>)

RELATED

  * rotate

  * rotaxis

  * scale

}

{
transpose

REPLACED BY
  - hou.Matrix4.transposed()

Transposes a matrix.

USAGE
  transpose(<mat>)

}

{
trunc
Converts a number to an integer by truncating any fractional part,
rounding towards 0.

USAGE
  trunc(<number>)

The number is rounded toward 0. That is, for positive numbers, the
largest integer less than the number will be returned. For negative
numbers, the smallest integer greater than the number will be returned.

EXAMPLES

  > trunc(2.6)=2
  > trunc(-2.6)=-2

RELATED

  * int

  * floor

  * ceil

  * round

  * frac

}

{
turb
Generates spatially coherent 3D noise.

USAGE
  turb(<X>, <Y>, <Z>, <depth>)

Spatially coherent noise gives random numbers which are close to each
other when the X, Y, Z inputs are close to each other.

<depth> is the amount of fractalization done to the noise.

The noise is calculated on a unit-spaced lattice. This means the noise
will be independent between points one unit distance apart. You can
scale the inputs to achieve different frequencies.

The range is usually within -1 to 1, but can exceed it depending on the
depth. The maximum range is -2 to 2 for high depths.

RELATED

  * sturb

  * noise

  * snoise

}

{
uniqueval
Returns a unique value of an integer attribute.

USAGE
  uniqueval(<surface_node>, <class>, <attribute>, <index>)

The <class> can be one of D_VERTEX, D_POINT, D_PRIMITIVE, or D_DETAIL
for the corresponding attribute class.

EXAMPLES

  > uniqueval("/obj/geo1/facet1", D_PRIMITIVE, "piece", 0)
    Returns the first unique integer value associated with the primitive
    attribute piece in the facet1 surface node in geo1.

}

{
uniquevals
Returns a unique value of a string attribute.

USAGE
  uniquevals(<surface_node>, <class>, <attribute>, <index>)

The <class> can be one of D_VERTEX, D_POINT, D_PRIMITIVE, or D_DETAIL
for the corresponding attribute class.

EXAMPLES

  > uniquevals("/obj/geo1/facet1", D_PRIMITIVE, "name", 0)
    Returns the first unique string value associated with the primitive
    attribute "name" in the facet1 surface node in geo1.

}

{
unituv
Converts real UV to unit UV.

USAGE
  unituv(<surface_node>, <prim_num>, <uv_real>, <D_U|D_V>)

The unit value is defined in the [0,1] interval. The real value is
defined in the valid interval of the primitive's domain if the primitive
is a spline type. If the primitive is a polygon or a mesh, the size of
its domain is given by the number of vertices, or rows or columns
respectively. If the primitive is a polygon or a curve, D_U and D_V are
irrelevant.


NOTE
    the result is undefined if the primitive is neither a face nor a
    hull.

RELATED

  * realuv

}

{
uvdist
Returns the distance between parameteric locations on two primitives.

USAGE
  `uvdist(<surface_node>, <prim1_num>, <u1>, <v1>, <surface_node>,
  <prim2_num>, <u2>, <v2>)`

Valid u and v values are between 0 and 1.

Any primitive type is allowed.

EXAMPLES

  > uvdist("/obj/geo1/sphere1", 0, 0.1, 0.8, "/obj/geo1/grid1", 2, 1, 0.5)
    Returns the distance between point (0.1, 0.8) on the first primitive
    in sphere1 and point (1, 0.5) on the third primitive in grid1.

RELATED

  * distance

  * primdist

  * pointdist

  * unituv

}

{
vangle

REPLACED BY
  - hou.Vector3.angleTo()

Returns the angle between two vectors.

USAGE
  vangle(<v0>, <v1>)

vangle(a, b) will return the same result as acos ( dot (normalize(a),
normalize(b)) ). It will not produce a negative result because the dot
product is symmetric, and does not take the order of a and b into
consideration.

You can define a turning order with the left hand rule or something
similar.


TIP
    Try the following expression to get a signed result:
    sign(dot(cross(cross(a,b),b),a)) * vangle(a,b)

}

{
vector
Converts a string specification into a vector.

USAGE
  vector(<pattern>)

The pattern should consist of a leading square bracket followed by a
comma-separated list of values and a closing square bracket.

To access a value out of the vector, use the square bracket operator.

EXAMPLES

  > vector v = vector("[1,2,3,4,5]");
  > float  f = v[0]; # f is 1

}

{
vector3
Converts three values into a 3-component vector.

USAGE
  vector3(<x>, <y>, <z>)

The pattern should consist of a leading square bracket followed by a
comma-separated list of values and a closing square bracket.

To access a value out of the vector, use the square bracket operator.

EXAMPLES

  > vector v = vector3(3,2,1);
  > float  f = v[0]; # f is 3

}

{
vector4
Converts four values into a 4-component vector.

USAGE
  vector4(<x>, <y>, <z>, <w>)

To access a value out of the vector, use the square bracket operator.

EXAMPLES

  > vector v = vector4(3,2,1,0);
  > float  f = v[0]; # f is 3

}

{
vertex

REPLACED BY
  - hou.Vertex.attribValue()

Returns the value of a vertex attribute.

USAGE
  `vertex(<surface_node>, <primitive_number>, <vertex_number>,
  <attribute>, <index>)`

<attribute> is the name of the attribute (eg. "Cd" for diffuse color).
Two special attributes exist "P" and "Pw" which represent the position
of the point in space ("Pw" allows you to access the W component of the
position).


NOTE
    This function will interpolate between point values if the vertex
    number is fractional, such as 3.35.

<index> specifies the component position in multi-component attributes
such as vectors, colors, and arrays. For example, if the attribute is a
color, an index value of 0 returns the red component, 1 returns the
green component, and 2 returns the blue component.

EXAMPLES

  > vertex("/obj/geo1/facet1", 2, 3, "P", 0)
    Return the X component of vertex 3 of primitive2 in the facet1
    surface node of geo1.

  > point("/obj/geo1/facet1", 2, 3, "Cd", 2)

    Returns the Z component of the color attribute of vertex 3 of
    primitive 2 in the facet1 surface node of object geo1.

RELATED

  * point

  * pointavg

}

{
vertexattribsize

REPLACED BY
  - hou.Attrib.size()

Returns the number of components in a vertex attribute.

USAGE
  vertexattribsize(<surface_node>, <attribute>)

If the surface node or attribute are not found, returns 0.

EXAMPLES

  > vertexattribsize( "/obj/model/sphere", "uv" )
    Returns the number of elements of a texture attribute.

RELATED

  * vertex

  * pointattribsize

  * primattribsize

  * detailattribsize

}

{
vertexattribtype
Returns the type of a vertex attribute.

USAGE
  vertexattribtype(<surface_node>, <attribute>)

If the surface node or attribute are not found, returns -1.


Types are
  * -1 - Unknown/Invalid

  * 0 - Integer

  * 1 - Float

  * 2 - String

EXAMPLES

  > vertexattribsize( "/obj/model/box", "Cd" )
    Returns 1 to denote a float attribute.

RELATED

  * vertex

  * pointattribtype

  * primattribtype

  * detailattribtype

}

{
vertexs

REPLACED BY
  - hou.Vertex.attribValue()

Returns the string value of a vertex attribute.

USAGE
  `vertexs(<surface_node>, <primitive_number>, <vertex_number>,
  <attribute>)`

EXAMPLES

  > vertexs("/obj/geo1/facet1", 1, 3, "instance")
    Returns the string associated with the string attribute "instance"
    for vertex 3 of primitive 0 in the facet1 surface node in geo1.

}

{
vertexsmap
Returns a string from a list of strings in a vertex attribute.

USAGE
  vertexsmap(<surface_node>, <attribute>, <index>)

This function will return the <index>th unique string bound to the given
point attribute. Use vertexsnummap to find the total number of unique
strings. Note that the exact order of the strings is should not be
relied upon. The indexes start with 0 and go to vertexsnummap()-1.

EXAMPLES

  > vertexsmap("/obj/geo1/attribcreate1", "foo", 0)
    Returns the first unique string in the foo attribute.

}

{
vertexsnummap
Returns the number of unique strings bound to a point attribute.

USAGE
  vertexsnummap(<surface_node>, <attribute>)

EXAMPLES

  > vertexsnummap("/obj/geo1/attribcreate1", "foo")
    Returns number of unique strings for the foo attribute.

}

{
vlength

REPLACED BY
  - hou.Vector3.length()

Returns the length of a vector.

USAGE
  vlength(<vec>)

A.K.A. sqrt(dot(<vec>, <vec>)).

}

{
vlength2

REPLACED BY
  - hou.Vector3.lengthSquared()

USAGE
  vlength2(<vec>)

Compute the square of the length of the vector specified. This is
equivalent to: dot(vec, vec).

}

{
vmatch

REPLACED BY
  - hou.vmatch()

Channel segment function: matches the incoming and outgoing slopes.

USAGE
  vmatch()

The values at each end of the segment will be determined by the values
specified at the segment ends.

RELATED

  * match

  * vmatchin

  * vmatchout

}

{
vmatchin

REPLACED BY
  - hou.vmatchin()

Channel segment function: matches the incoming slope.

USAGE
  vmatchin()

The segment will be a straight line matching the slope of the previous
segment, but using the starting value specified a the beginning of this
segment.

RELATED

  * matchin

  * vmatch

  * vmatchout

}

{
vmatchout

REPLACED BY
  - hou.vmatchout()

Channel segment function: matches the outgoing slope.

USAGE
  vmatchout()

Compute a straight line which has the same slope as the in coming slope
of the next segment. The straight line will end at the value specified.

RELATED

  * matchout

  * vmatch

  * vmatchin

}

{
volumeaverage
Returns the average value of all the voxels in a volume.

USAGE
  volumeaverage(<surface_node>, <prim_id>)

<surface_node> is the full path of the surface node. <prim_id> is the
primitive number of the volume primitive within the surface node.

Returns 0 if out of bound values are specified, or the given primitive
is not a volume or VDB.

EXAMPLES

  > volumeaverage("/obj/geo1/isooffset1", 0)

RELATED

  * volumesample

}

{
volumegradient
Returns the gradient of a volume primitive at a specified location.

USAGE
  `volumegradient(<surface_node>, <prim_id>, <x>, <y>, <z>,
  <axis>)`

The gradient of a volume primitive is a three dimensional vector
pointing in the direction of increasing value in the volume primitive.
It is returned in surface space (as opposed to the volume's local space
or world space).

<surface_node> is the full path of the surface node. <prim_id> is the
primitive number of the volume primitive within the surface node.

<axis> controls which component of the gradient is returned:

  * <axis> = 0: X-axis

  * <axis> = 1: Y-axis

  * <axis> = 2: Z-axis

Returns 0 if out of bound values are specified, or the given primitive
is not a volume.

EXAMPLES

  > volumegradient("/obj/geo1/isooffset1", 0, $TX, $TX, $TZ, 1)

RELATED

  * volumesample

}

{
volumeindex
Returns the value of a volume primitive at a specified voxel.

USAGE
  volumeindex(<surface_node>, <prim_id>, <ix>, <iy>, <iz>)

The coordinates are in terms of the voxel grid, not world coordinates.
0, 0, 0 means the first voxel.

<surface_node> is the full path of the surface node. <prim_id> is the
primitive number of the volume primitive within the surface node.

Returns 0 if out of bound values are specified, or the given primitive
is not a volume.

EXAMPLES

  > volumeindex("/obj/geo1/isooffset1", 0, 3, 4, 5)

RELATED

  * volumesample

}

{
volumeindextopos
Converts volume voxel coordinates to world-space coordinates.

USAGE
  volumeindextopos(<surface_node>, <prim_id>, <ix>, <iy>, <iz>, <axis>)

Returns the world-space coordinates of the center of the given voxel.

<surface_node> is the full path of the surface node. The <prim_id> is
the primitive number of the volume primitive within the surface node.

<axis> controls which component of the voxel index is returned:

  * <axis> = 0: X-axis

  * <axis> = 1: Y-axis

  * <axis> = 2: Z-axis

Returns 0 if out of bound values are specified, or the given primitive
is not a volume.

EXAMPLES

  > volumeindextopos("/obj/geo1/isooffset1", 0, $TX, $TY, $TZ, 0)

RELATED

  * volumepostoindex

  * volumesample

}

{
volumemax
Returns the maximum value of all voxels in a volume.

USAGE
  volumemax(<surface_node>, <prim_id>)

<surface_node> is the full path of the surface node.

<surface_node> is the full path of the surface node. <prim_id> is the
primitive number of the volume primitive within the surface node.

Returns 0 if out of bound values are specified, or the given primitive
is not a volume or VDB.

EXAMPLES

  > volumemax("/obj/geo1/isooffset1", 0)

RELATED

  * volumemin

  * volumesample

}

{
volumemin
Returns the minimum value of all voxels in a volume.

USAGE
  volumemin(<surface_node>, <prim_id>)

<surface_node> is the full path of the surface node.

<surface_node> is the full path of the surface node. <prim_id> is the
primitive number of the volume primitive within the surface node.

Returns 0 if out of bound values are specified, or the given primitive
is not a volume or VDB.

EXAMPLES

  > volumemin("/obj/geo1/isooffset1", 0)

RELATED

  * volumemax

  * volumesample

}

{
volumepostoindex
Converts world space coordinates to volume voxel coordinates.

USAGE
  volumepostoindex(<surface_node>, <prim_id>, <x>, <y>, <z>, <axis>)

This function will return the voxel closest to the given worldspace
coordinated. The axis selects which coordinate is returned.

<surface_node> is the full path of the surface node. The <prim_id> is
the primitive number of the volume primitive within the surface node.

Returns 0 if out of bound values are specified, or the given primitive
is not a volume.

<axis> controls which component of the world space position is returned:

  * <axis> = 0: X-axis

  * <axis> = 1: Y-axis

  * <axis> = 2: Z-axis

EXAMPLES

  > volumepostoindex("/obj/geo1/isooffset1", 0, 3, 4, 5, 0)

RELATED

  * volumeindextopos

  * volumesample

}

{
volumeres
Returns the resolution of a volume.

USAGE
  volumeres(<surface_node>, <prim_id>, <axis>)

<surface_node> is the full path of the surface node. The <prim_id> is
the primitive number of the volume primitive within the surface node.

<axis> controls which component of the resolution is returned:

  * <axis> = 0: X-axis

  * <axis> = 1: Y-axis

  * <axis> = 2: Z-axis

Returns 0 if out of bound values are specified, or the given primitive
is not a volume.

EXAMPLES

  > volumeres("/obj/geo1/isooffset1", 0, 1)

RELATED

  * volumesample

}

{
volumesample
Returns the value of a volume at a specified position.

USAGE
  volumesample(<surface_node>, <prim_id>, <x>, <y>, <z>)

<surface_node> is the full path of the surface node. <prim_id> is the
primitive number of the volume primitive within the surface node.

Returns 0 if out of bound values are specified, or the given primitive
is not a volume or VDB.

EXAMPLES

  > volumesample("/obj/geo1/isooffset1", 0, $TX, $TX, $TZ)

RELATED

  * volumeindex

  * volumegradient

}

{
volumevoxeldiameter
Returns the approximage diameter of a volume voxel in world space.

USAGE
  volumevoxeldiameter(<surface_node>, <prim_id>)

<surface_node> is the full path of the surface node. <prim_id> is the
primitive number of the volume primitive within the surface node.

Returns 0 if out of bound values are specified, or the given primitive
is not a volume.

EXAMPLES

  > volumevoxeldiameter("/obj/geo1/isooffset1", 0)

RELATED

  * volumeindex

  * volumesample

}

{
vorigin

REPLACED BY
  - hou.ObjNode.getTransformToNode()

Returns a vector of an objects' transforms.

USAGE
  vorigin(<obj1>, <obj2>)

This function will return a vector with 6 values in it. The values are
set to [TX, TY, TZ, RX, RY, RZ] for the position of obj1 relative to
obj2.

This can also be thought of as the position of obj2 relative to obj1.

If the empty string ("") is specified for either obj1 or obj2, then the
identity transform will be used instead. For example, if obj1 is the
empty string, then the world space position of obj2 is returned.

RELATED

  * origin

  * vtorigin

  * vrorigin

  * originoffset

}

{
vpname
Takes a viewer name and a viewport number and returns the viewport's
name.

USAGE
  vpname(<viewer>, <viewport_quadrant_number>)

}

{
vrorigin

REPLACED BY
  - hou.Matrix4.extractRotates()
  - hou.ObjNode.getTransformToNode()

Returns a vector of an object's rotations.

USAGE
  vrorigin(<obj1>, <obj2>)

This function will return a vector containing the rotates required to
transform obj1 to the space of obj2.

This can also be thought of as the orientation of obj2 relative to obj1.

If the empty string ("") is specified for either obj1 or obj2, then the
identity transform will be used instead. For example, if obj1 is the
empty string, then the world space rotation of obj2 is returned.

RELATED

  * origin

  * vorigin

  * vtorigin

  * originoffset

}

{
vscale

REPLACED BY
  - hou.Vector3.__mul__()
  - hou.Vector3.__rmul__()

Multiplies a vector by a scaling factor.

USAGE
  vscale(<vec>, <scale>)

A.K.A <vex> * <scale>.

}

{
vset

REPLACED BY
  - hou.Vector3.setTo()

Creates a vector with each component set to the same value.

USAGE
  vset(<size>, <value>)

Returns a vector of size <size>, with each component set to <value>.

}

{
vsize
Returns the number of elements in a vector.

USAGE
  vsize(<vec>)

}

{
vtorigin

REPLACED BY
  - hou.Matrix4.extractTranslates()
  - hou.ObjNode.getTransformToNode()

Returns a vector of an object's translations.

USAGE
  vtorigin(<obj1>, <obj2>)

This function will return a vector containing the translates required to
transform obj1 to the space of obj2.

This can also be thought of as the position of obj2 relative to obj1.

If the empty string ("") is specified for either obj1 or obj2, then the
identity transform will be used instead. For example, if obj1 is the
empty string, then the world space position of obj2 is returned.

RELATED

  * origin

  * vorigin

  * vrorigin

  * originoffset

}

{
wrap

REPLACED BY
  - hou.hmath.wrap()

Wraps a value between a minimum and maximum.

USAGE
  wrap(<value>, <minimum>, <maximum>)

Similar to the clamp expression in that the resulting value will always
fall between the specified minimum and maximum value. It will, however,
create a sawtooth wave for continuously increasing or decreasing values
of the value.

EXAMPLES

  > wrap ($F, 5, 10)
    Creates a sawtooth function between 5 and 10.

}

{
xyzdist

REPLACED BY
  - hou.Geometry.nearestPrim()
  - hou.Prim.nearestToPosition()

Returns the distance between a 3D coordinate and a primitive.

USAGE
  `xyzdist(<x>, <y>, <z>, <surface_node>, <prim_num>,
  <return_type>)`

If the <prim_num> is -1, finds the closest distance to any primitive in
the surface node.

  * return_type = 0 returns the minimum distance.

  * return_type = 1 returns the u parametric value at the point of
    minimum distance.

  * return_type = 2 returns the v parametric value at the point of
    minimum distance.

  * return_type = 3 returns the primitive number that was closest.

EXAMPLES

  > xyzdist(1, 2, 3, "/obj/geo1/grid1", 0, 0)
    Returns the distance between (1, 2, 3) and the closest spot from the
    surface of grid1 primitive number 0. If the return_type were 1, the
    u parametric value that is closest to the point would be returned.

RELATED

  * primdist

  * nearpoint

  * pointdist

}

