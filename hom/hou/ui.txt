= hou.ui =
#type: hommodule
#cppname: HOM_ui
#group: ui

"""Module containing user interface related functions."""

@functions

== Pane layout ==

::`curDesktop()` -> [Hom:hou.Desktop]:
    #cppname: HOM_ui::curDesktop
    #replaces: Cmd:desk
    Return the current desktop.

::`desktop(name)` -> [Hom:hou.Desktop]:
    #cppname: HOM_ui::desktop
    #replaces: Cmd:desk
    Return the desktop with the specified name.
    Return None if no such desktop exists.

::`desktops()` -> `tuple` of [Hom:hou.Desktop]:
    #cppname: HOM_ui::desktops
    #replaces: Cmd:desk
    Return all the desktops.

    See [Hom:hou.Desktop#setAsCurrent] for an example.

::`addDesktop(name)`:
    #cppname: HOM_ui::addDesktop
    #replaces: Cmd:desk
    #status: ni

::`radialMenu(name)` -> [Hom:hou.RadialMenu]:
    #cppname: HOM_ui::radialMenu
    
    Returns a [Hom:hou.RadialMenu] object representing the named menu,
    or `None` if the menu does not exist.

::`radialMenus()` -> `tuple` of [Hom:hou.RadialMenu]:
    #cppname: HOM_ui::radialMenus
    
    Returns a tuple of [Hom:hou.RadialMenu] objects representing existing menus.

::`createRadialMenu(name, label)` -> `tuple` of [Hom:hou.RadialMenu]:
    #cppname: HOM_ui::createRadialMenu
    
    Creates a new radial menu object with the given name and label.

::`panes(self)` -> `tuple` of [Hom:hou.Pane]:
    #cppname: HOM_ui::panes
    Return a tuple of all visible panes, including those in all floating
    windows.

    See also [Hom:hou.Desktop#panes].

::`paneTabs(self)` -> `tuple` of [Hom:hou.PaneTab]:
    #cppname: HOM_ui::paneTabs
    Return a tuple of all visible pane tabs, including those in all floating
    windows.

    See also [Hom:hou.Desktop#paneTabs].

::`currentPaneTabs(self)` -> `tuple` of [Hom:hou.PaneTab]:
    #cppname: HOM_ui::currentPaneTabs
    Return a tuple of all visible pane tabs that are selected in their
    containing panes, including those in all floating windows.

    See also [Hom:hou.Desktop#currentPaneTabs].

::`floatingPaneTabs(self)` -> `tuple` of [Hom:hou.PaneTab]:
    #cppname: HOM_ui::floatingPaneTabs
    Return all the pane tabs in floating panels.

    See also [Hom:hou.Desktop#floatingPaneTabs].

::`paneTabOfType(self, type, index=0)` -> [Hom:hou.PaneTab] or `None`:
    #cppname: HOM_ui::paneTabOfType
    Find and return the pane tab with the desired type.  If no such tab
    exists, return None.

    type:
    A [Hom:hou.paneTabType] enumerated variable.

    index:
    If there are multiple tabs with the desired type, this parameter
    determines which one is returned.  Use `index=0` to return the first
    found tab, `index=1` to return the second found tab, etc.  By default,
    index is 0.

    See also [Hom:hou.Desktop#paneTabOfType].

::`findPane(self, pane_id)` -> [Hom:hou.Pane] or None:
    #cppname: HOM_ui::findPane
    Return the pane with the given unique id, or `None` if no such pane exists.

    See also [Hom:hou.Desktop#findPane].

::`findPaneTab(self, name)` -> [Hom:hou.PaneTab] or None:
    #cppname: HOM_ui::findPaneTab
    Return the pane tab with the given name, or `None` if no such tab exists.

    The name may optionally be prefixed by the desktop name and a period.

    See also [Hom:hou.Desktop#findPaneTab].

::`floatingPanels(self)` -> `tuple` of [Hom:hou.FloatingPanel]:
    #cppname: HOM_ui::floatingPanels
    Return all the visible floating panels.

    See also [Hom:hou.Desktop#floatingPanels].

::`paneUnderCursor(self)`:
    #cppname: HOM_ui::paneUnderCursor
    Return the [Hom:hou.Pane] object located under the mouse cursor.  Return
    `None` if no pane is located under the mouse cursor.
    
    This method searches all visible panes including panes not attached to the
    current desktop.

::`paneTabUnderCursor(self)`:
    #cppname: HOM_ui::paneTabUnderCursor
    Similar to [Hom:hou.ui#paneUnderCursor] but return the
    [Hom:hou.PaneTab] object instead located under the mouse cursor.  Return
    `None` if no pane tab is located under the mouse cursor.

    This method searches all visible pane tabs including pane tabs not attached
    to the current desktop.

== Scripted UI ==

::`displayConfirmation(text, severity=hou.severityType.Message, help=None,
title=None, details=None, details_label=None, suppress=hou.confirmType.OverwriteFile)` -> int:
    #cppname: HOM_ui::displayconfirmation
    Pop up a window with a message, OK and Cancel buttons, and wait for
    the user to press a button.  Return `True` if the user hits OK, otherwise
    return `False`. The `suppress` parameter is used to skip the display of
    this dialog if the user requested not to be shown this confirmation
    dialog again. This dialog also presents the user with a check box to
    indicate that they don't want to be presented with this dialog in the
    future.

    text:
        The message to display.

    severity:
        A [Hom:hou.severityType] value that determines which icon to display
        on the dialog.  Note that using `hou.severityType.Fatal` will exit
        Houdini after the user closes the dialog.

    help:
	    Additional help information to display below the main message.

    title:
	    The window's title.  If `None`, the title is "Houdini".

    details:
	    A string containing extra messages that is not visible unless the
	    user clicks "Show Details".

    details_label:
	    A string containing the label for the expand/collapse button that controls
	    whether or not the detail text is visible. If `details_expanded` is set
	    to true this parameter has no effect.

    {{{
    #!python
    '''Prompt the user if they want to overwrite a file, and save it if they
choose OK.'''
    if hou.ui.displayConfirmation("Overwrite the current hip file?", suppress=hou.confirmType.OverwriteFile):
        hou.hipFile.save()
    }}}


::`displayMessage(text, buttons=('OK',), severity=hou.severityType.Message, default_choice=0, close_choice=None, help=None, title=None, details=None, details_label=None, 
details_expanded=False)` -> int:
    #cppname: HOM_ui::displayMessage
    #replaces: Cmd:message
    Pop up a small window with a message and one or more buttons and wait for
    the user to press a button.  Return the index of the button the user
    pressed.

    text:
	    The message to display.

    buttons:
	    A sequence of strings containing the names of the buttons.  By default
	    the message window contains a single OK button.

    severity:
	    A [Hom:hou.severityType] value that determines which icon to display
	    on the dialog.  Note that using `hou.severityType.Fatal` will exit
	    Houdini after the user closes the dialog.

    default_choice:
	    The index of the button that is selected if the user presses enter.

    close_choice:
	    The index of the button that is selected if the user presses Escape
	    or closes the dialog.
    
    help:
	    Additional help information to display below the main message.

    title:
	    The window's title.  If `None`, the title is "Houdini".

    details:
	    A string containing extra messages that is not visible unless the
	    user clicks "Show Details".

    details_label:
	    A string containing the label for the expand/collapse button that controls
	    whether or not the detail text is visible. If `details_expanded` is set
	    to true this parameter has no effect.

    details_expanded:
	    A boolean, if true then the text area where the detail messages appear
	    is always shown and cannot be collapsed. If false, the detail message
	    area is initially folded when the message box is popped up and the
	    user can expand to read the details.

    {{{
    #!python
    def saveIfNeeded():
	    '''Prompt the user if they want to save, and save the hip file if they choose Yes.'''
	    if hou.ui.displayMessage("Save the current hip file?", buttons=("Yes", "No")) == 0:
	        hou.hipFile.save()
    }}}

::`readInput(message, buttons=('OK',), severity=hou.severityType.Message, default_choice=0, close_choice=None, help=None, title=None, initial_contents=None)` -> (`int`, `str`):
    #cppname: HOM_ui::readInput
    Pop up a small window with a textbox and wait for the user to enter a line
    of text.  Return a tuple containing an integer and the text they entered.
    The integer is the index of the pressed button.  If `close_choice` is not
    None and the user closed the dialog by clicking on its close button or by
    pressing Escape, then the returned integer is set to `close_choice`.

    message:
	    The message to display above the text field.

    buttons:
	    A sequence of strings containing the names of the buttons.  By default
	    the message window contains a single OK button.

    severity:
	    A [Hom:hou.severityType] value that determines which icon to display
	    on the dialog.  Note that using `hou.severityType.Fatal` will exit
	    Houdini after the user closes the dialog.

    default_choice:
	    The index of the button that is selected if the user presses enter.
    
    close_choice:
	    The index of the button that is selected if the user presses Escape
	    or clicks on the dialog's close button.  If there is more than one
	    button and `close_choice` is None, then the user cannot close the
	    dialog with Escape or the dialog's close button.  If there is
	    only one button and `close_choice` is None, then the user can close the
	    dialog with Escape or the dialog's close button, and the button's index
	    is returned.

    help:
	    Additional help information to display below the main message.

    title:
	    The window's title.  If `None`, the title is "Houdini".

    initial_contents:
	    The initial contents of the text field.  If `None`, the text field is
	    initially empty.

    See also [Hom:hou.ui#readMultiInput] 

::`readMultiInput(message, input_labels, password_input_indices=(), buttons=('OK',), severity=hou.severityType.Message, default_choice=0, close_choice=None, help=None, title=None, initial_contents=(0,))` -> (`int`, `tuple` of `str`):
    #cppname: HOM_ui::readMultiInput
    Pop up a small window with a textbox and wait for the user to enter a text
    into several input fields.
    Return a tuple containing an integer and the tuple of strings they entered,
    one for each input field.
    The integer is the index of the pressed button.  If `close_choice` is not
    None and the user closed the dialog by clicking on its close button or by
    pressing Escape, then the returned integer is set to `close_choice`.

    message:
	    The message to display above the text field.

    input_labels:
	    A sequence of labels to appear in front of each input field. The
	    length of the sequence determines the number of input fields that will
	    appear in the window.

    password_input_indices:
	    A sequence of indices of which input fields are password fields.
	    Fields whose index is not in this sequence will not be password fields.

    buttons:
	    A sequence of strings containing the names of the buttons.  By default
	    the message window contains a single OK button.

    severity:
	    A [Hom:hou.severityType] value that determines which icon to display
	    on the dialog.  Note that using `hou.severityType.Fatal` will exit
	    Houdini after the user closes the dialog.

    default_choice:
	    The index of the button that is selected if the user presses enter.

    close_choice:
	    The index of the button that is selected if the user presses Escape
	    or clicks on the dialog's close button.  If there is more than one
	    button and `close_choice` is None, then the user cannot close the
	    dialog with Escape or the dialog's close button.  If there is
	    only one button and `close_choice` is None, then the user can close the
	    dialog with Escape or the dialog's close button, and the button's index
	    is returned.
    
    help:
	    Additional help information to display below the main message.

    title:
	    The window's title.  If `None`, the title is "Houdini".

    initial_contents:
	    The list that specifies the initial contents of each of the text field.
	    The length of the list does not need to be the same as the number of the
	    input fields. If it is shorter, then initially the remaining input
	    fields will be empty.

    See also [Hom:hou.ui#readInput] 

::`selectFile(start_directory=None, title=None, collapse_sequences=False, file_type=hou.fileType.None, pattern=None, default_value=None, multiple_select=False, image_chooser=False, chooser_mode=hou.fileChooserMode.ReadAndWrite)` -> `str`:
    #cppname: HOM_ui::selectFile
    #replaces: Cmd:filechooser
    Pop up a window with a file chooser dialog and wait for the user to
    choose a file name.  Return the path to the file that was selected.

    start_directory:
	    The directory the dialog should initially start in.

    title:
	    The window title for the dialog.

    collapse_sequences:
	    Whether sequences of files with common numeric patterns should be
	    collapsed into patterns containing $F.

    file_type:
	    A [Hom:hou.fileType] enumerated value to say what type of file to
	    select.  The set of visible files is determined by this file type
	    and the pattern.

    pattern:
	    Only files matching this pattern (and anything restricted by the file
	    type) will be listed.  By default, everything matches the pattern.

    default_value:
	    The default contents of the file name field in the dialog.

    multiple_select:
	    Whether the user may select multiple files.

    image_chooser:
	    Whether the dialog shows image thumbnails.

    chooser_mode:
	    A [Hom:hou.fileChooserMode] enumeration value to say if the user is
	    being prompted for a file to read from, write to, or either.

::`selectFromList(choices, default_choices=(), exclusive=False, message=None, title=None, column_header="Choices", num_visible_rows=10, clear_on_cancel=False)` -> `tuple` of `int`:
    #cppname: HOM_ui::selectFromList
    #replaces: Cmd:listchooser
    Pop up a window with a set of choices in a list box and prompt the user to
    choose zero or more of them.  If selection is accepted then the list of
    selected row indices are returned.  If selection is cancelled then the
    initial selection (default choices) is returned.

    choices:
	    A sequence of strings containing the possible choices.

    default_choices:
	    A sequence of integers containing the indices of the choices that
	    are initially selected.

    exclusive:
	    Whether or not the user must choose exactly one of the possible choices.

    message:
	    The message to display above the list box.

    title:
	    The window's title.  If `None`, the title is "Houdini".

    column_header
	    The column header for the list of choices.  Users can click this header
	    label to sort the list.  If `None`, then the header is removed.  Note that
	    the tuple of integers represents the original order of items,
	    regardless of the displayed sort order.

    num_visible_rows:
	    The number of rows of entries that are visible at a time.  If there
	    are more possible choices than visible rows, Houdini will use a
	    scrollbar.

    clear_on_cancel:
	    If set to True then an empty tuple is returned when selection is cancelled.
	    Otherwise the initial selection (default_choices) is returned when
	    selection is cancelled.

::`selectFromTree(choices, picked=(), exclusive=False, message=None, title=None, clear_on_cancel=False)` -> `tuple` of `str`:
    #cppname: HOM_ui::selectFromTree
    #replaces: Cmd:treechooser
    Pop up a window with a set of choices in a tree chooser and prompt the user
    to choose zero or more of them.  The choices are arranged into a tree using
    a forward slash as a path separator.  If selection is accepted then the
    list of selected paths are returned.  If selection is cancelled then
    the initial selection (picked) is returned.

    choices:
	    A sequence of strings containing the possible choices.

    picked:
	    A sequence of strings containing the items that should be
	    initially selected.

    exclusive:
	    Whether or not the user must choose exactly one of the possible choices.

    message:
	    The message to display above the list box.

    title:
	    The window's title.  If `None`, the title is "Make Selection".

    clear_on_cancel:
	    If set to True then an empty tuple is returned when selection is cancelled.
	    Otherwise the initial selection (picked) is returned when
	    selection is cancelled.

::`selectNode(relative_to_node=None, initial_node=None, node_type_filter=None)` -> `str` or `None`:
    #cppname: HOM_ui::selectNode
    Pop up a window with a node tree view and prompt the user to choose a node.

    If the user selects a node, returns a string containing the path to the
    node.  If the user presses clear, returns an empty string.  If the user
    presses cancel, returns `None`.

    relative_to_node:
	    A [Hom:hou.Node] for relative paths, or `None` if relative paths are
	    not supported.  Passing in a node enables the Use Relative Paths
	    checkbox.

	    If this parameter is supplied and the user checks the Use Relative
	    Paths checkbox, this function returns a relative path to the node.

    initial_node:
	    The [Hom:hou.Node] that is initially selected.

    node_type_filter:
	    An optional [Hom:hou.nodeTypeFilter] enumerated value that determines
	    which types of nodes appear in the tree view.

    The following function takes a [Hom:hou.Parm], prompts the user to choose
    a node, and sets the value of the parameter as long as the user does not
    click cancel.
    {{{
    #!python
    def setParmOnNode(parm, node_type_filter=None):
	    path = hou.ui.selectNode(relative_to_node=parm.node(), node_type_filter=node_type_filter)
	    if path is not None:
	        parm.set(path)
    }}}

    You might call this function as follows:
    {{{
    #!pycon
    >>> setParmOnNode(hou.parm("/obj/box_object1/shop_materialpath"), hou.nodeTypeFilter.Shop)
    }}}

::`selectMultipleNodes(relative_to_node=None, initial_node=None, node_type_filter=None)` -> `tuple` of `str` or `None`:
    #cppname: HOM_ui::selectMultipleNodes
    Same behavior as selectNode however if the user holds 'Ctrl' they
    can select multiple nodes which are returned as a list of paths.

::`selectAttrib(initial_selection=(), multiple_select=False, expand_components=True)` -> `tuple` of `([Hom:hou.Attrib], int)`
    #cppname: HOM_ui::selectAttrib
    Pop up a chooser dialog that prompts the user to select a geometry
    attribute in the scene.  Return a tuple of the selected attributes
    represented as pairs of [Hom:hou.Attrib] and integer values.  Return
    an empty tuple if the selection operation was cancelled.

    `initial_selection`:
        Optionally set this argument to a tuple of attributes to be
        pre-selected when the chooser dialog opens.  The tuple must contain
        pairs of [Hom:hou.Attrib] and integer pairs.  This matches the
        structure of the tuple that is returned by the function.  If
        `expand_components` is set to True then the integer values in the tuple
        must be set to -1.

    `multiple_select`:
        If set to True then the user can select multiple attributes from the
        chooser dialog.

    `expand_components`:
        If set to True then the chooser dialog displays the components of the
        attributes (i.e. `P[0]`, `P[1]`, `P[2]`) and the user is prompted to
        select an attribute component.  In this case the integer values in the
        returned tuple are set to selected component indices.

        If set to False then the user is prompted to select attributes and the
        integer values in the returned tuple are set to -1.

    Example:
    {{{
    #!python
    # Pre-select the 2nd component of the 'myAttr' point attribute on the
    # /obj/geo1/OUT Sop node.
    attrib = hou.node("/obj/geo1/OUT").geometry().findPointAttrib("myAttr")
    attrib_component_index = 1
    preselected_attribs=((attrib, attrib_component_index), )

    # Prompt the user to select an attribute.
    selected_attribs = hou.ui.selectAttrib(
        initial_selection=preselected_attribs)

    # Output the selected attribute.
    print selected_attribs
    }}}

    Example with `expand_components` set to False:
    {{{
    #!python
    # Pre-select the 'myAttr' point attribute on the
    # /obj/geo1/OUT Sop node.
    attrib = hou.node("/obj/geo1/OUT").geometry().findPointAttrib("myAttr")
    attrib_component_index = -1
    preselected_attribs=((attrib, attrib_component_index), )

    # Prompt the user to select an attribute.
    selected_attribs = hou.ui.selectAttrib(
        initial_selection=preselected_attribs,
        expand_components=False)

    # Output the selected attribute.
    print selected_attribs
    }}}

::`selectNodeData(title=None, message=None, width=0, height=0, initial_selection=0, node_type_filter=None, multiple_select=False, include_data_type_headers=True, include_parms=True, include_object_transforms=True, include_geometry_bounding_boxes=True, include_geometry_attributes=True, expand_components=True, custom_data_callback=None, help_url=None)` -> `dict`
    #cppname: HOM_ui::selectNodeData
	
    Pop up a chooser dialog that prompts the user to select data from a node.
    The data can be a parameter, a component from an object node's transform,
    a geometry node's bounding box property, a geometry attribute, or even
    custom data defined by the `custom_data_callback` argument.  Return a
    dictionary of selected data organized by the following keys :
	
    - Parameters
        Contains a tuple of selected parameters.  The elements in the tuple
        are [Hom:hou.Parm] objects.  If `expand_components` is False then
        the elements are [Hom:hou.ParmTuple] objects.
    - Transforms
        Contains a tuple of selected object node transforms or 
        transform components.  The elements in the tuple are 3-tuples of the
        form `(node, transform_type, transform_component)` where `node` is the
        [Hom:hou.Node] object that the selected transform is pulled from,
        `transform_type` is the type of transform (either Local or World), and
        `transform_component` is the specific component selected from the
        transform (i.e. `Rotate[X]`).  If the whole transform is selected
        instead of a component then `transform_component` is `None`.
    - Bounding Boxes
        Contains a tuple of selected geometry node bounding box properties.
        The elements in the tuple are 2-tuples of the form 
        `(node, bbox_property)` where `node` is the [Hom:hou.Node] object
        that the selected bounding box property is pulled from, and
        `bbox_property` is the specific bounding box property (i.e. `Size[X]`).
    - Attributes
        Contains a tuple of selected geometry attributes or attribute
        components.  The elements in the tuple are 2-tuples of the form
        `(attrib, attrib_index)` where `attrib` is the selected 
        [Hom:hou.Attrib] object and `attrib_index` is the index of the selected
        attribute component.  If `expand_components` is False then
        `attrib_index` is always -1.
    - Custom
        Contains a tuple of selected custom data as specified by the
        `custom_data_callback` argument.  The elements in the tuple are
        2-tuples of the form `(node, custom_data)` where `node` is the selected
        [Hom:hou.Node] object that the custom data is attached to and
        `custom_data` is the actual data.

    NOTE:
        If no data is selected for a specific key then the key does not exist
        in the dictionary.  For example, if no parameters are selected then
        the Parameters key does not exist.

    `title`:
        The chooser dialog's window title.  If set to `None` then the window
        title defaults to "Choose Node Data".

    `message`:
        Optional messaging to appear in the chooser dialog below the node data
        tree.

    `width`:
        The chooser dialog's width.  If 0, then the chooser dialog uses a
        default width.

    `height`:
        The chooser dialog's height.  If 0, then the chooser dialog uses a
        default height.

    `initial_selection`:
        Optionally set this argument to a dictionary of node data to be
        pre-selected when the chooser dialog opens.  The dictionary must
        contain at least one of the Parameters, Transforms, Attributes,
        Custom keys.  The values of the keys must be tuples of elements that
        match the elements of the returned dictionary.  For example, the
        Parameters tuple must contain [Hom:hou.Parm] or [Hom:hou.ParmTuple]
        objects.  The Transforms tuple must contain `(node, transform_type,
        transform_component)` tuples.  The Attributes tuple must contain
        `(attrib, attrib_index)` tuples.  The Custom tuple must contain
        `(node, custom_data)` tuples.

    `node_type_filter`:
        An optional [Hom:hou.nodeTypeFilter] enumerated value that determines
        which types of nodes appear in the tree view.

    `multiple_select`:
        If set to True then the user can select multiple node data from the
        chooser dialog.

    `include_data_type_headers`:
        If set to True then headers appear in the node data tree for each of the
        data types (i.e. Parameters, Transforms, Attributes) except for the
        Custom data type.

    `include_parms`:
        Include parameters in the node data tree.

    `include_object_transforms`:
        Include object transforms in the node data tree.

    `include_geometry_bounding_boxes`:
        Include geometry bounding boxes in the node data tree.

    `include_geometry_attributes`:
        Include geometry attributes in the node data tree.

    `expand_components`:
        If set to True then the chooser dialog displays the sub-components of
        parameters (i.e. `tx` instead of `t`), transforms (i.e.  `Rotate[X]`
        instead of `Rotate`) and attributes (i.e. `P[0]` instead of `P`).  The
        user is prompted to select sub-components instead of the complete data.

    `custom_data_callback`:
        A Python callback function that is invoked for each node in the chooser
        dialog.  The callback accepts a single [Hom:hou.Node] argument and
        returns a string tuple of custom data to appear in the node.

        You can specify subpaths for the custom data to organize them into
        a tree hierarchy.  For example, if the callback returns
        `("Fruits/Apples", "Fruits/Bananas", "Fruits/Oranges")` then a Fruits
        row will appear in the node with Apples, Bananas and Oranges inside of
        Fruits.

        Note that the non-leaf parts of a custom data path are not selectable.
        If you want those parts to be selectable then return them as separate
        entries in the tuple.  For example, if you want Fruits to also be
        selectable then the callback should return `("Fruits", "Fruits/Apples",
        "Fruits/Bananas", "Fruits/Oranges")`.


    `help_url`:
        Optional argument for associating a help page with the node data
        chooser.  If this argument is specified then a '?' help button appears
        in the chooser dialog.

    Basic Example:
	
    {{{
    #!python
    # Prompt to select node data.  Show all types of data.
    selected_data = hou.ui.selectNodeData()

    # Print out selected parameters (if any).
    if "Parameters" in selected_data:
        for parm in selected_data["Parameters"]:
            print "Selected Parm: ", parm

    # Print out selected object transforms (if any).
    if "Transforms" in selected_data:
        for xform_info in selected_data["Transforms"]:
            print "Selected Node: ", xform_info[0]
            print "Selected Transform Type: ", xform_info[1]
            print "Selected Transform Component: ", xform_info[2]

    # Print out selected geometry bounding boxes (if any).
    if "Bounding Boxes" in selected_data:
        for bbox_info in selected_data["Bounding Boxes"]:
            print "Selected Node: ", bbox_info[0]
            print "Selected Bounding Box Property: ", bbox_info[1]

    # Print out selected geometry attributes (if any).
    if "Attributes" in selected_data:
        for attr_info in selected_data["Attributes"]:
            print "Selected Attribute: ", attr_info[0]
            print "Selected Attribute Index: ", attr_info[1]
    }}}

    Here is an example of setting an initial selection:
	
    {{{
    #!python
    # Pre-select the 'tx', 'ty' and 'tz' parameters on /obj/geo1.
    preselected_parms = (
        hou.parm("/obj/geo1/tx"), hou.parm("/obj/geo1/ty"), 
        hou.parm("/obj/geo1/tz"))

    # Pre-select the scale z world transform component on /obj/geo1.
    preselected_xforms = (
        (hou.node("/obj/geo1"), "World", "Scale[Z]"),
    )

    # Pre-select the centroid y bounding box property on /obj/geo1/OUT.
    preselected_bboxes = (
        (hou.node("/obj/geo1/OUT"), "Centroid[Y]"),
    )

    # Pre-select the 2nd component of the 'myAttr' point attribute on the
    # /obj/geo1/OUT Sop node.
    attrib = hou.node("/obj/geo1/OUT").geometry().findPointAttrib("myAttr")
    attrib_component_index = 1
    preselected_attribs=((attrib, attrib_component_index), )

    # Build up the initial selection dictionary.
    initial_selection = {
        "Parameters" : preselected_parms,
        "Transforms" : preselected_xforms,
        "Bounding Boxes" : preselected_bboxes,
        "Attributes" : preselected_attribs,
    }

    # Prompt the user to select node data.
    selected_data = hou.ui.selectNodeData(
        initial_selection=initial_selection,
        multiple_select=True)

    # Output the selected data.
    print selected_data
    }}}

    Here is an example of specifying custom data:
    {{{
    #!python
    # Define the callback for returning custom data.
    def getCustomData(node):
        # Add custom data only on Object nodes.
        if node.type().category().name() == "Object":
            return ["Fruits/Apples", "Fruits/Bananas", "Fruits/Oranges"]

        # Don't add custom data on all other nodes.
        return []

    # Prompt the user to select node data.
    selected_data = hou.ui.selectNodeData(custom_data_callback=getCustomData)

    # Output the selected data.
    print selected_data
    }}}

::`selectParmTag()` -> `tuple` of `str`:
    #cppname: HOM_ui::selectParmTag
    Pop up a window with a tree view of recognized parameter tags and prompt
    the user to choose a tag.  Parameter tags are metadata that can be attached
    to a parameter template with [Hom:hou.ParmTemplate#setTags] and queried
    with [Hom:hou.ParmTemplate#tags].

    Tags listed in the window are recognized by Houdini.  For example, choosing
    the GL Diffuse tag and assigning it to a parameter template causes the
    viewport to recognize the parameter as the diffuse color.

    This method returns a 2-tuple where the first element is the selected tag
    name and the second element is the selected tag value.  If no tag is
    selected or if the selection operation is cancelled, then a 2-tuple of
    empty strings is returned.

::`selectParm(category=None, bound_parms_only=False, relative_to_node=None, message=None, title=None, initial_parms=(), multiple_select=True)` -> `tuple` of `str`:
    #cppname: HOM_ui::selectParm
    Pop up a window with a parameter tree view and prompts the user to select
    parameters, populated initially with `initial_parms`.  
    If selection is accepted then a list of selected parameter paths are
    returned.  If selection is cancelled then the initial selection (initial
    parameters) is returned.

    category:
    A [Hom:hou.NodeTypeCategory] if filtering by node type, otherwise `None` 
    if all parameters should be shown

    bound_parms_only:
    True if the dialog should only display parameters that are bound to a default
    handle. False is all parameters should be shown.

    relative_to_node:
    A [Hom:hou.Node] that you want the selected parameters paths to be relative to.

    message:
    The message to display in the dialog.

    title:
    The title of the dialog.

    multiple_select:
    Whether the user may select multiple parameters.

::`selectParmTuple(category=None, bound_parms_only=False, relative_to_node=None, message=None, title=None, initial_parm_tuples=(), multiple_select=True)` -> `tuple` of `str`:
    #cppname: HOM_ui::selectParmTuple
    Pop up a window with a parameter tree view and prompts the user to select
    parameter tuples, populated initially with `initial_parm_tuples`.

    See [Hom:hou.ui#selectParm] for documentation on the arguments.

::`selectColor(initial_color=None)` -> [Hom:hou.Color] or `None`:
    #cppname: HOM_ui::selectColor
    Pop up a window with a color chooser, and waits for the user to choose a
    color and hit the OK or Cancel button. If the user hits the OK button,
    this method returns the color chosen in the dialog. If the user hits
    Cancel, this method rturns `None`.

    The `initial_color` parameter specifies a [Hom:hou.Color] that will appear
    in the dialog when it first opens. If not set, the initial color will be
    white.

::`openColorEditor( color_change_callback, include_alpha=False, initial_color=None, initial_alpha=1.0)`:
    #cppname: HOM_ui::openColorEditor
    Open the Houdini color editor and return immediately.

    When a change is made in the editor then the `color_change_callback`
    function is invoked and passed the editor's current color and alpha value.

    If `include_alpha` is True then the color editor shows controls for editing
    the color's alpha value.

    The `initial_color` parameter specifies a [Hom:hou.Color] that will appear
    in the editor when it first opens. If not set, the initial color will be
    white.

    The `initial_alpha` parameter specifies an alpha value to use when
    the editor first opens.  If not set, the initial alpha will be 1.0.
    Note that the `initial_alpha` parameter only applies if `include_alpha`
    is set to True.

    The `color_change_callback` argument must be a function that accepts
    two parameters -- a [Hom:hou.Color] object and an alpha value.

    Here is an example:
    {{{
    #!python
    def handleColorChange(color, alpha):
	print "Current color in editor:", color, ", alpha=", alpha

    hou.ui.openColorEditor(handleColorChange)
    }}}

::`openValueLadder(initial_value, value_changed_callback, type=hou.valueLadderType.Generic, data_type=hou.valueLadderDataType.Float)`:
    #cppname: HOM_ui::openValueLadder
    Open the Houdini value ladder window that typically appears when ((MMB)
    clicking on an input field.  This function returns immediately.  The window
    remains open until [Hom:hou.ui#closeValueLadder] is called.

    Only one value ladder window can be opened at a time.  This function raises
    [Hom:hou.OperationFailed] if another ladder window is currently open.

    `initial_value` is the numeric value that the ladder window is initially
    set to when it opens.

    `value_changed_callback` is a callback function that is invoked whenever
    the value in the window changes.  The function accepts a single argument
    which is the current ladder value.

    `type` specifies the type of value ladder window to open.  It must be a
    [Hom:hou.valueLadderType] enumeration value.

    `data_type` specifies the type of data that the value ladder window displays.
    It must be a [Hom:hou.valueLadderDataType] enumeration value.

    This examples demonstrates how to add value ladder window support to an input
    field class that derives from Qt's QLineEdit class:

    {{{
    #!python

    from PySide2 import QtWidgets

    class LineEditWithValueLadder(QtWidgets.QLineEdit):
        def __init__(self):
            QtWidgets.QLineEdit.__init__(self)
        self.isValueLadderOpen = False

        def mousePressEvent(self, event):
        # Show the value ladder window if MMB was pressed.
            if event.button() == QtCore.Qt.MiddleButton and modifiers == 0:
                hou.ui.openValueLadder(
            0.0, self._handleXCFValueChange,
                    hou.valueLadderType.Generic,
                    hou.valueLadderDataType.Float)
                self.isValueLadderOpen = True

        def mouseMoveEvent(self, event):
        if self.isValueLadderOpen:
            hou.ui.updateValueLadder(
                    event.globalX(), event.globalY(),
                    bool(event.modifiers() & QtCore.Qt.AltModifier),
                    bool(event.modifiers() & QtCore.Qt.ShiftModifier))

            def mouseReleaseEvent(self, event):
            if event.button() == QtCore.Qt.MiddleButton and self.isValueLadderOpen:
                hou.ui.closeValueLadder()
                self.isValueLadderOpen = False

        def _handleXCFValueChange(self, ladder_value):
            str_value = str(ladder_value)
            self.setText(str_value)

            # Notify observers that the text contents have changed.
            self.textChanged.emit(str_value)
    }}}

::`updateValueLadder(cursor_x, cursor_y, alt_key, shift_key)`:
    #cppname: HOM_ui::updateValueLadder
    Updates the value in the currently opened ladder value window based on the
    given cursor position and boolean arguments.

    This function only works if [Hom:hou.ui#openValueLadder] was previously
    called.  Raises [Hom:hou.OperationFailed] if no value ladder window is
    currently open.

    `cursor_x` must be the x-coordinate for the current mouse cursor position.

    `cursor_y` must be the y-coordinate for the current mouse cursor position.

    Set `alt_key` to True to inform the ladder window that the Alt key is held down.
    Holding down the Alt key while changing the ladder value will scale the
    value.

    Set `shift_key` to True to inform the ladder window that the Shift key is
    held down.  Holding down the Shift key while changing the ladder value will
    change the active level in the ladder window.

    For example code, see the Value Ladder example in the @examples section below.

::`closeValueLadder()`:
    #cppname: HOM_ui::closeValueLadder
    Close the current value ladder window that was open by a previous call
    to [Hom:hou.ui#openValueLadder].

    Raise [Hom:hou.OperationFailed] if no value ladder window is open.

    For example code, see the Value Ladder example in the @examples section below.


== Help ==

::`displayNodeHelp(node_type)`:
    #cppname: HOM_ui::displayNodeHelp
    #replaces: Cmd:ophelp
    Display the help for the specified node type.  If no help browser is open,
    this function will create a new one.

    If you want to display the help for a node instance, it is easy to access
    the [Hom:hou.NodeType] from the node, as illustrated in this example:
    {{{
    #!python
    def displayHelpForNode(node):
    '''Given a hou.Node, display its help.'''
    hou.ui.displayNodeHelp(node.type())
    }}}

== Windows ==

::`openTypePropertiesDialog(node_or_node_type, promote_spare_parms=False, immediately_save=False)`:
    #cppname: HOM_ui::openTypePropertiesDialog
    #replaces: Cmd:otedit, Cmd:propertyedit
    Given a [Hom:hou.Node] or [Hom:hou.NodeType] instance, open the spare
    properties dialog.

    promote_spare_parms:
	    If this parameter is True and you passed in a node instance,
	    automatically promote any spare parameters on the node into
	    parameters on the node type.

    immediately_save:
	    When true, immediately save the current state of the node type,
	    as if you clicked "Apply" in the type properties dialog.

::`openRenderDialog(rop_node)`:
    #cppname: HOM_ui::openRenderDialog
    Given a [Hom:hou.RopNode] instance, open the render control dialog for
    the node. This dialog can be used to override certain render parameters,
    and launch a render.

::`openRenameSelectedDialog(node)`:
    #cppname: HOM_ui::openRenameSelectedDialog
    Given a [Hom:hou.Node] which contains other nodes, open a dialog for
    renaming all selected children of the node. The dialog uses pattern
    matching to rename all the selected nodes in one operation.

::`displayFileDependencyDialog(rop_node=None, uploaded_files=(), forced_unselected_patterns=(), project_dir_variable='HIP', is_standalone=true)` -> (`bool`, tuple of Parm and string tuples):
    #cppname: HOM_ui::displayFileDependencyDialog
    Open a dialog displaying the file dependencies in the current .hip file.

    Return a 2-tuple where the first element in the tuple is True if the dialog
    was closed with the OK button and False otherwise, and the second element
    is a tuple of the selected file patterns.  Each selected file pattern is
    represented as a <[Hom:hou.Parm], string> pair which stores the source
    parameter that contains the file pattern and the file pattern itself.

    NOTE:
	    If the source parameter is not None then it is recommended that file
	    pattern expansion be performed by evaluating the parameter's value
	    instead of calling [Hom:hou.expandString].  Evaluating the source
	    parameter is far more accurate since it accounts for channel references
	    and context-specific variables like $OS.

::`showFloatingDetailsViewWindow(node)`:
    #cppname: HOM_Node::showFloatingDetailsViewWindow
    #replaces: Cmd:oppane
    #status: ni

::`showFloatingParmWindow(node)`:
    #cppname: HOM_Node::showFloatingParmWindow
    #replaces: Cmd:oppane
    #status: ni

::`makeSureChannelEditorIsOpen()`:
    #cppname: HOM_ui::makeSureChannelEditorIsOpen
    #replaces: Cmd:chscope
    #status: ni

::`openCaptureWeightSpreadsheet(node, pattern=None)`:
    #cppname: HOM_ui::openCaptureWeightSpreadsheet
    Given an instance of a [Hom:hou.SopNode] that is a 'captureoverride' type, 
    open the edit capture weight spreadsheet for the node. If a string is passed 
    for pattern, then only the points specified by the pattern will be shown, 
    otherwise all the points for the node will be displayed in the spreadsheet.

== Status line ==

::`setStatusMessage(message, severity=hou.severityType.Message)`:
    #cppname: HOM_ui::setStatusMessage
    Display a message in Houdini's status bar.

    `severity`:
	    A [Hom:hou.severityType] enum value that determines the background
	    color of the message.

    To clear the status bar, call `hou.ui.setStatusMessage("")`.

== Callbacks ==

::`addEventLoopCallback(callback)`:
    #cppname: HOM_ui::addEventLoopCallback
    Register a Python callback to be called whenever Houdini's event loop is
    idle.  This callback is called approximately every 50ms, unless Houdini
    is busy processing events.

    callback:
        Any callable Python object that expects no parameters.  It could be
        a Python function, a bound method, or any object implementing
        `__call__`.

    {{{
    #!python
    def checkForAndProcessEvents():
        # Here is where you would check for and process any events.
        pass
        hou.ui.addEventLoopCallback(checkForAndProcessEvents)
    }}}

    You might use this function to integrate another user interface toolkit
    into Houdini's event loop.  See the [PyQt|/hom/cookbook/pyqt/part1] and
    [wxPython|/hom/cookbook/wxPython] cookbook examples for example usages.

::`addSelectionCallback(callback)`:
    #cppname: HOM_ui::addSelectionCallback
    Register a Python callback to be called whenever Houdini's global network
    item selection changes.

    callback:
        Any callable Python object that expects a single parameter. This
	parameter will be a list of all selection [Hom:hou.NetworkMovableItem]
	objects that are now selected. It could be a Python function, a bound
	method, or any object implementing `__call__`.

    {{{
    #!python
    def selectionCallback(selection):
        # Here is where you would respond to the selection change.
        pass
    hou.ui.addSelectionCallback(selectionCallback)
    }}}

::`waitUntil(condition_callback)`:
    #cppname: HOM_ui::waitUntil
    
    Keep calling the supplied callback until it returns True.  In the meantime,
    Houdini will continue to be responsive, allowing you to continue to
    interact with it.

    For example, start a blank Houdini session and put the following in a shelf
    tool.  It will wait until you create an object node before finishing
    running the tool.
    
    {{{
    #!python
    print "waiting until you create an object..."
    hou.ui.waitUntil(lambda: len(hou.node("/obj").children()) > 0)
    print "you created", hou.node("/obj").children()
    }}}

    If you find that your callback function is too slow to be run frequently, you can try only making it do work every so often:
    
    {{{
    #!python
    import time
    
    def throttle(callback, delay=2.0):
        # Returns a wrapper function around `callback`, which only calls
        # `callback` every `delay` seconds (default 2.0), no matter
        # how often the wrapper function is called.
        
        # This can be useful if the condition function is expensive to run,
        # so you want to limit how often it is called.
        
        # Store in a list, since Python 2.x doesn't have full nonlocal keyword
        last_check = [0.0]
        
        def wrapper():
            now = time.time()
            if now < _last_check[0] + delay:
                # Since we return False when we're inside the delay, Houdini
                # will continue to call the condition function
                return False
            else:
                _last_check[0] = now
                return callback()
    
    
    # Then you could use this with hou.waitUntil like this:
    
    def my_callback():
        return len(hou.node("/obj").children()) > 0
    
    hou.waitUntil(throttle(my_callback, delay=0.5))
    }}}

::`eventLoopCallbacks()` -> `tuple` of callback:
    #cppname: HOM_ui::eventLoopCallbacks
    Return a tuple of all the Python callbacks that have been registered with
    [Hom:hou.ui#addEventLoopCallback].

::`processPendingEvents()`:
    #cppname: HOM_ui::update
    #replaces: updateui
    #status: ni

::`removeEventLoopCallback(callback)`:
    #cppname: HOM_ui::removeEventLoopCallback
    Remove a Python callback that was previously registered with
    [Hom:hou.ui#addEventLoopCallback].  See [Hom:hou.ui#addEventLoopCallback]
    for more information.

    Raises [Hom:hou.OperationFailed] if the callback was not previously
    registered.

::`removeAllSelectionCallbacks()`:
    #cppname: HOM_ui::removeAllSelectionCallbacks
    Remove all Python callbacks previously registered with
    [Hom:hou.ui#addSelectionCallback].  See [Hom:hou.ui#addSelectionCallback]
    for more information.

::`removeSelectionCallback(callback)`:
    #cppname: HOM_ui::removeSelectionCallback
    Remove a Python callback that was previously registered with
    [Hom:hou.ui#addSelectionCallback].  See [Hom:hou.ui#addSelectionCallback]
    for more information.

::`selectionCallbacks()` -> `tuple` of callback:
    #cppname: HOM_ui::selectionCallbacks
    Return a tuple of all the Python callbacks that have been registered with
    [Hom:hou.ui#addSelectionCallback].

== Updating the viewport ==

::`triggerUpdate()`:
    #cppname: HOM_ui::triggerUpdate
    #replaces: Cmd:viewupdate
    Force the viewports to update and perform any cooks necessary.  You might
    call this function when Houdini's Auto Update mode is on Manual.

::`reloadViewportColorSchemes()`:
    #cppname: HOM_ui::triggerUpdate
    
    Reloads all `3DSceneColors` configuration files (in `$HFS/houdini/config`).
    You must cause the viewport to redraw (for example, by tumbling)
    to see the new colors.
    
    This function may be useful if you are implementing a new color scheme:
    you can map to a hotkey or call it in the Python console so you can check
    your changes.

::`updateMode()` -> [Hom:hou.updateMode] enum value:
    #cppname: HOM_ui::updateMode
    This method is deprecated in favor of [Hom:hou.updateModeSetting].

::`setUpdateMode(mode)`:
    #cppname: HOM_ui::setUpdateMode
    This method is deprecated in favor of [Hom:hou.setUpdateMode].


== Settings ==

::`resourceValueFromName(self, name)` -> `str`:
    #cppname: HOM_ui::resourceValueFromName

    Return a string value from a symbolic resource name. The resource name
    should correspond to one of the entries in the `$HH/config/*.hcs` file
    for the currently selected color scheme.

    Raises: [Hom:hou.ValueError] if the provided symbolic name doesn't exist.

::`colorFromName(self, name)` -> [Hom:hou.Color]:
    #cppname: HOM_ui::colorFromName

    Return a color value from a symbolic color name. The color name should
    correspond to one of the entries in the `$HH/config/*.hcs` file for the
    currently selected color scheme.

    Raises: [Hom:hou.ValueError] if the provided symbolic name doesn't exist.

    For example:
    {{{
    #!python
    >>> hou.ui.colorFromName("DisplayOnColor")
    <hou.Color r=0.3, g=0.5, b=1>
    }}}
    
    TIP:
        You can use [Hom:hou.qt.getColor] to get a Qt color object instead
        of a HOM color object.

::`orientationUpAxis(self)` -> [Hom:hou.orientUpAxis] enum value:
    #cppname: HOM_ui::orientationUpAxis

    Return a hou.orientUpAxis indicating the current orientation mode's up axis.

::`handleOrientToNormalAxis(self)` -> [Hom:hou.handleOrientToNormalAxis] enum value:
    #cppname: HOM_ui::handleOrientToNormalAxis

    Return a hou.handleOrientToNormalAxis indicating the handle axis that is to be aligned to component normals when orienting.


::`inchesToPixels(self, inches)` -> `float`:
    #cppname: HOM_ui::inchesToPixels

    Return the supplied `inches` argument, expressing a distance on the
    screen, converted to a number of pixels. This calculation combines the
    number of dots per inch reported by the operating system, the
    `Global UI Size` setting accessible from
    __Edit > Preferences > General User Interface__,
    and the `HOUDINI_UISCALE` environment variable, if it has been set. As
    such, this value may not be accurate, but is consistent with the way
    the rest of Houdini converts distances from inches to pixels.

::`pixelsToInches(self, pixels)` -> `float`:
    #cppname: HOM_ui::pixelsToInches

    Return the supplied `pixels` argument, expressing a number of pixels on the
    screen, converted to a distance in inches. This calculation combines the
    number of dots per inch reported by the operating system, the
    `Global UI Size` setting accessible from
    __Edit > Preferences > General User Interface__,
    and the `HOUDINI_UISCALE` environment variable, if it has been set. As
    such, this value may not be accurate, but is consistent with the way
    the rest of Houdini converts distances from pixels to inches.

::`globalScaleFactor(self)` -> `float`:
    #cppname: HOM_ui::globalScaleFactor
    Return the scale factor that is set by Houdini's Global UI Size preference.
    For example, this function returns 1.0 when Houdini is set to the Normal UI
    size.

    The scale factor can be used to scale components in a PySide or PyQt built
    UI where [Hom:hou.ui#scaledSize] cannot be called.  For example, the scale
    factor can be used to set the zoom factor of a QWebEngineView object so
    that the web contents match the Global UI Size:
    {{{
    #!python
    web_view = QWebEngineWidgets.QWebEngineView()
    web_view.setZoomFactor(hou.ui.globalScaleFactor())
    }}}

::`scaledSize(self, size)` -> `int`:
    #cppname: HOM_ui::scaledSize
    Scale the specified size by the global UI scale factor and return the
    scaled size.  The scale factor is determined by Houdini's Global UI Size
    preference.  For example, the factor is 1.0 when Houdini is set to the
    Normal UI size.

    This function is useful for scaling hard-coded sizes in PySide or PyQt
    code.  Here is an example of using scaled sizes when setting a widget
    to a fixed size that is 640x480 with the Normal UI size:
	
    {{{
    #!python
    widget = QtWidgets.QWidget()
    widget.resize(hou.ui.scaledSize(640), hou.ui.scaledSize(480))
    }}}

    Here is another example of creating a scaled icon using the
    [Hom:hou.qt#createIcon] function:
    {{{
    #!python
    icon = hou.qt.createIcon(hou.ui.scaledSize(32), hou.ui.scaledSize(32))
    }}}

::`loadPaletteFile(self, file)` -> `tuple` of [Hom:hou.Color]:
    #cppname: HOM_ui::loadPaletteFile
    Load a palette file and return the colors listed in the palette. The
    `file` parameter can be a full path, or just a file name. In the latter
    case, the Houdini path is searched for the first instance of the named
    file under the `config` subdirectory.

::`savePaletteFile(self, file, colors)`:
    #cppname: HOM_ui::savePaletteFile
    Save a palette file with the contents of the `colors` parameter, a tuple
    of [Hom:hou.Color] objects. The `file` parameter must be a full path to
    the file where the palette should be saved.

    Raises [Hom:hou.OperationFailed] if the file could not be written.

== Clipboard ==

::`copyTextToClipboard(self, text)`:
    #cppname: HOM_ui::copyTextToClipboard

    Sets the supplied text into the system clipboard.

::`getTextFromClipboard(self)` -> `str`:
    #cppname: HOM_ui::getTextFromClipboard

    Returns any text currently copied into the system clipboard. If the
    clipboard is empty or contains non-text data, an empty string is returned.

== Python shell ==

::`writePythonShellHistoryFile(filename=None)`:
    #cppname: HOM_ui::writePythonShellHistoryFile
    Save the command history from the current Python Shell to disk.
    If `filename` is None, then the history is written to 
    $HOME/houdiniX.X/pyshell.history.  If this function is invoked
    outside of a Python Shell, then the history is taken from the 
    last active shell (i.e. the last shell that was opened or accepted input).

    Raises [Hom:hou.OperationFailed] if no Python Shell has been opened.
    Raises [Hom:hou.OperationFailed] if `filename` cannot be created.

::`readPythonShellHistoryFile(filename=None)`:
    #cppname: HOM_ui::readPythonShellHistoryFile
    Load the contents from the specified file into the command history
    of the Python Shell.  If `filename` is None, then the history is read
    from $HOME/houdiniX.X/pyshell.history.  If this function is invoked
    outside of a Python Shell, then the history is loaded into the
    the last active shell (i.e. the last shell that was opened 
    or accepted input).

    Raises [Hom:hou.OperationFailed] if no Python Shell has been opened.
    Raises [Hom:hou.OperationFailed] if `filename` does not exist or cannot
    be read.

::`shellIO()` -> [Hom:hou.ShellIO]:
    #cppname: HOM_ui::shellIO
    Return the [Hom:hou.ShellIO] object used to implement Houdini's graphical
    Python shell.  This function is used internally by Houdini, and you
    shouldn't need to access the ShellIO directly.

== Drag and drop ==

::`hasDragSourceData(label)`:
    #cppname: HOM_ui::hasDragSourceData
    Query the current drag source to determine if the specified data type is
    available.

    Raises [Hom:hou.NotAvailable] if no drag operation is currently active.

::`getDragSourceData(label, index)`:
    #cppname: HOM_ui::hasDragSourceData
    Query the current drag source to obtain the dragged data.  Returns
    None when the specified data in unavailable (or unsupported by HOM).

    Raises [Hom:hou.NotAvailable] if no drag operation is currently active.

== Qt integration ==

::`mainQtWindow(self)`:
    #cppname: HOM_ui::_mainQtWindow
    This method is deprecated.  Call [Hom:hou.qt#mainWindow] instead.

::`createQtIcon(name, width=32, height=32)`:
    #cppname: HOM_ui::_createQtIcon
    This method is deprecated.  Call [Hom:hou.qt#Icon] instead.

::`qtStyleSheet()`:
    #cppname: HOM_ui::qtStyleSheet
    This method is deprecated.  Call [Hom:hou.qt#styleSheet] instead.

== Dialog scripts ==

::`createDialog(ui_file_name)` -> [Hom:hou.Dialog]:
    #cppname: HOM_ui::createDialog
    Parse the given .ui file and return the dialog defined in the file.

    The dialog must be written with Houdini's User Interface Script Language.
    An overview of the language can be found in the Houdini Development Kit
    (HDK) documentation, specifically in the "Houdini User Interface -> The .ui
    Script Language" section.

    `ui_file_name` is the basename of the .ui file.  The file must be located
    in a directory registered with the HOUDINI_UI_APP_PATH search path.  For a
    list of HOUDINI_UI_APP_PATH search directories, run `hconfig -ap`
    from a terminal.

    Raises [Hom:hou.OperationFailed] if the .ui file contains errors and the
    dialog could not be created.
    Raises [Hom:hou.TypeError] if `ui_file_name` is `None`.

::`findDialog(ui_file_name)` -> [Hom:hou.Dialog]:
    #cppname: HOM_ui::findDialog
    Return the dialog defined by the given .ui file name and created by
    [Hom:hou.ui#createDialog].

    Return `None` if no dialog has been created with [Hom:hou.ui#createDialog]
    for the specified .ui file.

    Raises [Hom:hou.TypeError] if `ui_file_name` is `None`.

::`dialogs()` -> `tuple` of [Hom:hou.Dialog]:
    #cppname: HOM_ui::dialogs
    Return all dialogs created by [Hom:hou.ui#createDialog].


== Misc ==

::`beginUploadingAssetFromNode(node, session_key)`:
    #cppname: HOM_ui::beginUploadingAssetFromNode
    #status: ni


== Viewer states ==

::`registerViewerState(template)`
    #cppname: HOM_ui::registerViewerState

    Registers a [Hom:hou.ViewerStateTemplate] object representing a custom viewer state. 
    See [installing viewer states|/hom/python_states#install] for how to use this function.

    `template`:
        The [Hom:hou.ViewerStateTemplate] object.

    Raises [Hom:hou.NameConflict] if the registration fails because a state with the same name is already registered.
    Raises [Hom:hou.OperationFailed] if the registration fails (for example, the state to register has no factory).

::`unregisterViewerState(state_name)`
    #cppname: HOM_ui::unregisterViewerState
  
    Unregisters an existing viewer state type. 

    See [installing viewer states|/hom/python_states#install] for how to use this function.
    
    `state_name`:
        The name of the state to unregister.

    Raises [Hom:hou.OperationFailed] if the unregistration fails (for example, if no state with the given name is registered).

::`isRegisteredViewerState(state_name)` -> `bool`
    #cppname: HOM_ui::isRegisteredViewerState

    Returns `True` if `state_name` has previously been registered with [Hom:hou.ui#registerViewerState]. Returns `False` if not.

    `state_name`:
        The name of the state to validate.

::`reloadViewerState(state_name)`
    #cppname: HOM_ui::reloadViewerState
  
    Update a registered viewer state by reloading its python module file from a `viewer_states` folder. 
    This method works with `self-installed` states only. `Embedded` states can be updated simply by editing the code and re-saving the HDA. See [installing states in Houdini|/hom/python_states#install] for more details.
    
    WARNING:
        If you get an error message about a registration problem during a reload like the following,
        
        `Error registering 'my_state': factory not specified or invalid.`

        The state will be removed from Houdini and you will be forced to quit Houdini to fix the problem.
          
    `state_name`:
        The name of the state to reload.

    Raises [Hom:hou.OperationFailed] if the reload fails (for example, if no state with the given name is registered).

::`reloadViewerStates(state_names=None)`
    #cppname: HOM_ui::reloadViewerState
  
    Reload multiple viewer states as specified in the `state_names` array. If the array is empty, all registered [self-installed|/hom/python_states#install] states in Houdini are reloaded. See [Hom:hou.ui#reloadViewerState] for more details on reloading a state.  
          
    `state_names`:
        Array of state names to reload. Empty by default.

    Raises [Hom:hou.OperationFailed] if the reload fails (for example, if no state with a given name is registered).

== Hotkeys ==

::`hotkeys(self, hotkey_symbol)` -> `tuple` of `str`:
    #cppname: HOM_ui::hotkeys

    Return a tuple of strings that represent the hotkeys currently assigned to
    the action associated with the hotkey symbol.  The hotkey symbols can be
    found in the `$HH/config/Hotkeys` directory.

    Raises: [Hom:hou.ValueError] if the provided hotkey symbol doesn't exist.

    For example:
    {{{
    #!pycon
    >>> hou.ui.hotkeys("h.copy")
    ('Alt+C', 'Ctrl+C')
    >>> hou.ui.hotkeys("h.pane.copytab")
    ('Ctrl+T',)
    }}}

::`hotkeyDescription(self, hotkey_symbol)` -> `str`:
    #cppname: HOM_ui::hotkeyDescription

    Return a string that contains a description of the action associated with
    the hotkey symbol.  The hotkey symbols can be found in the
    `$HH/config/Hotkeys` directory.

    Raises: [Hom:hou.ValueError] if the provided hotkey symbol doesn't exist.

    For example:
    {{{
    #!pycon
    >>> hou.ui.hotkeyDescription("h.pane.copytab")
    'Copy Tab'
    }}}

::`isKeyMatch(self, key, hotkey_symbol)` -> `bool`:
    #cppname: HOM_ui::isKeyMatch

    Return True if the key described by the string `key` matches one of the
    hotkeys assigned to the provided hotkey symbol. The hotkey symbols can be
    found in the `$HH/config/Hotkeys` directory.

    Raises: [Hom:hou.ValueError] if the provided hotkey symbol doesn't exist,
    or the key string doesn't represent a valid hotkey.

    For example:

    {{{
    #!pycon
    >>> hou.ui.isKeyMatch("Ctrl+C", "h.copy")
    True
    >>> hou.ui.isKeyMatch("Ctrl+C", "h.pane.copytab")
    False
    }}}

